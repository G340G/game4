<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THE LIMINAL ARCHIVE // PS2 HORROR</title>
    <style>
        :root { --scan-color: rgba(0, 0, 0, 0.5); }
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; user-select: none; }
        
        /* PS2 Low Res Container */
        #game-container {
            width: 100vw; height: 100vh;
            display: flex; justify-content: center; align-items: center;
            background: #000;
        }
        canvas {
            image-rendering: pixelated; /* THE PS2 LOOK */
            width: 100% !important; height: 100% !important;
            filter: contrast(1.2) brightness(0.9) sepia(0.2);
        }

        /* UI Overlays */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        
        /* CRT Scanlines */
        #scanlines {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none; opacity: 0.6;
        }
        
        /* HUD */
        #hud {
            position: absolute; bottom: 20px; left: 20px; color: #d0d0d0;
            text-shadow: 2px 2px 0 #000; font-size: 18px; font-weight: bold;
        }
        .bar { width: 200px; height: 10px; background: #333; margin-top: 5px; border: 1px solid #555; }
        .fill { height: 100%; transition: width 0.2s; }
        #hp-fill { background: #a00; width: 100%; }
        #san-fill { background: #00a; width: 100%; }

        /* Dialog Box */
        #dialog-box {
            display: none; position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%); width: 60%; background: rgba(0,0,0,0.9);
            border: 2px solid #fff; padding: 20px; color: #fff; text-align: center;
            pointer-events: auto; cursor: default;
        }
        .choice-btn {
            background: #333; border: 1px solid #fff; color: #fff;
            padding: 10px 20px; margin: 10px; cursor: pointer; font-family: inherit;
        }
        .choice-btn:hover { background: #fff; color: #000; }

        /* Start/Death Screen */
        #overlay-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: #fff; pointer-events: auto;
            z-index: 10;
        }
        h1 { font-size: 4em; letter-spacing: -5px; margin: 0; text-transform: uppercase; color: #d00; }
        p { max-width: 600px; text-align: center; line-height: 1.5; }
        button { background: #fff; color: #000; border: none; padding: 15px 30px; font-size: 1.2em; cursor: pointer; margin-top: 20px; font-family: 'Courier New'; font-weight: bold; }
        
        .glitch-text { animation: glitch 0.5s infinite; }
        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }
    </style>
</head>
<body>

    <div id="game-container"></div>
    
    <div id="ui-layer">
        <div id="scanlines"></div>
        <div id="hud">
            <div>PHYSICALITY</div>
            <div class="bar"><div id="hp-fill" class="fill"></div></div>
            <div style="margin-top:10px;">PSYCHE</div>
            <div class="bar"><div id="san-fill" class="fill"></div></div>
        </div>
    </div>

    <div id="dialog-box">
        <h2 id="npc-text"></h2>
        <div id="npc-choices"></div>
    </div>

    <div id="overlay-screen">
        <h1 class="glitch-text">LIMINAL</h1>
        <p>ESCAPE THE ASYLUM. FIND THE GREEN EXIT.<br>DO NOT LET THE ENTITY TOUCH YOU.</p>
        <p style="color:#888; font-size: 0.8em;">(HEADPHONES REQUIRED - INDUSTRIAL NOISE)</p>
        <button id="start-btn">INITIATE SEQUENCE</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- GAME CONFIG & STATE ---
        const config = {
            resScale: 0.25, // Internal resolution scale (PS2 pixelation)
            mazeSize: 21,   // Must be odd
            speed: 5.0,
            entitySpeed: 2.8
        };
        
        let state = {
            hp: 100,
            sanity: 100,
            isPlaying: false,
            isDialog: false,
            level: 1
        };

        // --- AUDIO SYSTEM (Procedural Industrial Noise) ---
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let droneOsc, lfo, gainNode, noiseNode, filterNode;

        function initAudio() {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            
            // Deep Industrial Drone
            droneOsc = audioCtx.createOscillator();
            droneOsc.type = 'sawtooth';
            droneOsc.frequency.value = 40;
            
            gainNode = audioCtx.createGain();
            gainNode.gain.value = 0.15;
            
            // LFO for dissonance
            lfo = audioCtx.createOscillator();
            lfo.frequency.value = 0.1; 
            const lfoGain = audioCtx.createGain();
            lfoGain.gain.value = 10;
            lfo.connect(lfoGain).connect(droneOsc.frequency);
            
            droneOsc.connect(gainNode).connect(audioCtx.destination);
            lfo.start();
            droneOsc.start();

            // Static/Hiss (The "Air" of the asylum)
            const bufferSize = audioCtx.sampleRate * 2;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

            noiseNode = audioCtx.createBufferSource();
            noiseNode.buffer = buffer;
            noiseNode.loop = true;
            
            filterNode = audioCtx.createBiquadFilter();
            filterNode.type = 'lowpass';
            filterNode.frequency.value = 800;
            
            const noiseGain = audioCtx.createGain();
            noiseGain.gain.value = 0.05;

            noiseNode.connect(filterNode).connect(noiseGain).connect(audioCtx.destination);
            noiseNode.start();
        }

        // --- PROCEDURAL TEXTURE GENERATORS (No external assets) ---
        
        function createCanvasTexture(color1, color2, type = 'noise') {
            const size = 256;
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = color1;
            ctx.fillRect(0,0,size,size);
            
            if(type === 'noise') {
                for(let i=0; i<5000; i++) {
                    ctx.fillStyle = Math.random() > 0.5 ? color2 : '#000';
                    ctx.globalAlpha = 0.2;
                    ctx.fillRect(Math.random()*size, Math.random()*size, 2, 2);
                }
            } else if (type === 'tile') {
                ctx.strokeStyle = color2;
                ctx.lineWidth = 4;
                ctx.strokeRect(0,0,size,size);
                // Grime
                for(let i=0; i<50; i++) {
                    ctx.fillStyle = 'rgba(0,0,0,0.3)';
                    const s = Math.random() * 40;
                    ctx.fillRect(Math.random()*size, Math.random()*size, s, s);
                }
            }
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.magFilter = THREE.NearestFilter; // PS2 style
            return tex;
        }

        function generateCreepyFace() {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // Base: Pale distorted skin
            ctx.fillStyle = '#dcdcdc';
            ctx.fillRect(0,0,size,size);
            
            // Noise overlay
            for(let i=0; i<20000; i++) {
                ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.1})`;
                ctx.fillRect(Math.random()*size, Math.random()*size, 2, 2);
            }

            // Distorted Eyes
            const eyeY = size * 0.4;
            ctx.fillStyle = '#000';
            const eyeSize = 40 + Math.random() * 60;
            ctx.beginPath();
            ctx.arc(size*0.3, eyeY + (Math.random()*40-20), eyeSize, 0, Math.PI*2);
            ctx.arc(size*0.7, eyeY + (Math.random()*40-20), eyeSize * (0.8 + Math.random()), 0, Math.PI*2);
            ctx.fill();
            
            // Red glowing pupils
            ctx.fillStyle = '#a00';
            ctx.beginPath();
            ctx.arc(size*0.3, eyeY, 5, 0, Math.PI*2);
            ctx.arc(size*0.7, eyeY, 5, 0, Math.PI*2);
            ctx.fill();

            // Screaming mouth
            ctx.fillStyle = '#110000';
            ctx.beginPath();
            const mouthW = 100 + Math.random() * 100;
            const mouthH = 100 + Math.random() * 100;
            ctx.ellipse(size/2, size*0.75, mouthW, mouthH, 0, 0, Math.PI*2);
            ctx.fill();
            
            // Teeth
            ctx.fillStyle = '#ffeedd';
            for(let i=0; i<10; i++) {
                ctx.fillRect(size/2 - mouthW + (i*20), size*0.75 - 50, 10, 40);
            }

            return new THREE.CanvasTexture(canvas);
        }

        // --- 3D SETUP ---
        const container = document.getElementById('game-container');
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth * config.resScale, window.innerHeight * config.resScale, false);
        renderer.domElement.style.width = "100%";
        renderer.domElement.style.height = "100%";
        container.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.15); // Thick darkness

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        
        // Flashlight
        const light = new THREE.PointLight(0xffffee, 1.5, 12);
        camera.add(light);
        scene.add(camera);

        const controls = new PointerLockControls(camera, document.body);

        // --- MAZE GENERATION (Recursive Backtracker) ---
        let walls = [];
        let floorPlan = [];
        let exitPos = new THREE.Vector3();
        
        function generateMaze(size) {
            // Reset
            walls.forEach(w => scene.remove(w));
            walls = [];
            floorPlan = Array(size).fill().map(() => Array(size).fill(1)); // 1 = Wall, 0 = Path

            const directions = [[0, 2], [2, 0], [0, -2], [-2, 0]];
            const stack = [[1, 1]];
            floorPlan[1][1] = 0;

            while (stack.length) {
                const [cx, cy] = stack[stack.length - 1];
                const neighbors = [];

                directions.forEach(([dx, dy]) => {
                    const nx = cx + dx, ny = cy + dy;
                    if (nx > 0 && nx < size - 1 && ny > 0 && ny < size - 1 && floorPlan[ny][nx] === 1) {
                        neighbors.push([nx, ny, cx + dx / 2, cy + dy / 2]);
                    }
                });

                if (neighbors.length) {
                    const [nx, ny, mx, my] = neighbors[Math.floor(Math.random() * neighbors.length)];
                    floorPlan[ny][nx] = 0;
                    floorPlan[my][mx] = 0; // Remove wall between
                    stack.push([nx, ny]);
                } else {
                    stack.pop();
                }
            }

            // Textures
            const wallTex = createCanvasTexture('#333', '#111', 'noise');
            const floorTex = createCanvasTexture('#222', '#444', 'tile');
            const matWall = new THREE.MeshLambertMaterial({ map: wallTex });
            const matFloor = new THREE.MeshLambertMaterial({ map: floorTex });

            // Build Geometry
            const geoBox = new THREE.BoxGeometry(2, 4, 2);
            
            for(let y=0; y<size; y++){
                for(let x=0; x<size; x++){
                    if(floorPlan[y][x] === 1) {
                        const wall = new THREE.Mesh(geoBox, matWall);
                        wall.position.set(x*2, 2, y*2);
                        scene.add(wall);
                        walls.push(wall);
                    } else {
                        // Floor
                        const floor = new THREE.Mesh(new THREE.PlaneGeometry(2,2), matFloor);
                        floor.rotation.x = -Math.PI/2;
                        floor.position.set(x*2, 0, y*2);
                        scene.add(floor);
                        
                        // Ceiling
                        const ceil = floor.clone();
                        ceil.position.y = 4;
                        ceil.rotation.x = Math.PI/2;
                        scene.add(ceil);

                        // Random avant-garde object spawning
                        if(Math.random() < 0.05 && !(x==1 && y==1)) {
                            spawnRandomObject(x*2, y*2);
                        }
                        
                        // NPC spawning
                        if(Math.random() < 0.02 && !(x==1 && y==1)) {
                            spawnNPC(x*2, y*2);
                        }
                    }
                }
            }

            // Set Player Start
            camera.position.set(2, 1.5, 2);
            
            // Set Exit (farthest point approx)
            exitPos.set((size-2)*2, 1, (size-2)*2);
            const exitGeo = new THREE.BoxGeometry(1, 1, 1);
            const exitMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
            const exitBox = new THREE.Mesh(exitGeo, exitMat);
            exitBox.position.copy(exitPos);
            scene.add(exitBox);
            walls.push(exitBox); // Treat as collidable but handled separately
        }

        // --- AVANT-GARDE OBJECTS ---
        function spawnRandomObject(x, z) {
            const types = ['cube', 'pyramid', 'eye'];
            const type = types[Math.floor(Math.random() * types.length)];
            let mesh;
            
            if(type === 'cube') {
                mesh = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.5), new THREE.MeshNormalMaterial());
            } else if (type === 'pyramid') {
                mesh = new THREE.Mesh(new THREE.ConeGeometry(0.4, 1, 4), new THREE.MeshBasicMaterial({color: 0xff0000, wireframe: true}));
            } else {
                // Eye
                mesh = new THREE.Mesh(new THREE.SphereGeometry(0.3, 8, 8), new THREE.MeshBasicMaterial({color: 0xffffff}));
                const pupil = new THREE.Mesh(new THREE.SphereGeometry(0.1, 8, 8), new THREE.MeshBasicMaterial({color: 0x000000}));
                pupil.position.z = 0.25;
                mesh.add(pupil);
            }
            
            mesh.position.set(x, 1.5 + Math.random(), z);
            scene.add(mesh);
            
            // Floating animation stored in userData
            mesh.userData = { 
                floatOffset: Math.random() * 10, 
                rotSpeed: Math.random() * 0.05 
            };
            walls.push(mesh); // Add to dynamic objects list for animation loop
        }

        // --- NPC SYSTEM ---
        const npcs = [];
        const questions = [
            { q: "DOES THE STATIC HURT?", a: [{t:"YES", e:"hp-"}, {t:"NO", e:"san-"}, {t:"I AM THE STATIC", e:"san+"}] },
            { q: "IS YOUR FACE YOUR OWN?", a: [{t:"YES", e:"sanity-"}, {t:"TOUCH FACE", e:"hp+"}] },
            { q: "THE WALLS ARE BREATHING.", a: [{t:"LET THEM", e:"san+"}, {t:"STOP THEM", e:"hp-"}] },
            { q: "WHERE IS THE EXIT?", a: [{t:"THERE IS NONE", e:"san-"}, {t:"FORWARD", e:"heal"}] }
        ];

        function spawnNPC(x, z) {
            // NPC is a 2D Sprite looking like a shadow person
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(64, 40, 30, 0, Math.PI*2); // Head
            ctx.fillRect(20, 70, 88, 180); // Body
            ctx.fill();
            
            // White static eyes
            ctx.fillStyle = '#fff';
            ctx.fillRect(40, 30, 10, 10);
            ctx.fillRect(80, 30, 10, 10);

            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({ map: tex });
            const sprite = new THREE.Sprite(mat);
            sprite.scale.set(1, 2, 1);
            sprite.position.set(x, 1, z);
            scene.add(sprite);
            
            npcs.push({ sprite: sprite, data: questions[Math.floor(Math.random()*questions.length)], active: true });
        }

        // --- THE ENTITY ---
        let entity;
        function spawnEntity() {
            if(entity) scene.remove(entity);
            const mat = new THREE.SpriteMaterial({ 
                map: generateCreepyFace(), 
                color: 0xffffff,
                transparent: true
            });
            entity = new THREE.Sprite(mat);
            entity.scale.set(1.5, 1.5, 1.5);
            // Spawn far away
            entity.position.set((config.mazeSize-2)*2, 1.5, (config.mazeSize-2)*2); 
            scene.add(entity);
        }

        // --- GAME LOGIC ---

        function updateHUD() {
            document.getElementById('hp-fill').style.width = `${state.hp}%`;
            document.getElementById('san-fill').style.width = `${state.sanity}%`;
            
            // Visual Distortion based on Sanity
            const distortion = (100 - state.sanity) / 100;
            document.querySelector('canvas').style.filter = 
                `contrast(${1 + distortion}) sepia(${0.2 + distortion}) hue-rotate(${distortion * 90}deg)`;
            
            // Audio distortion
            if(lfo) lfo.frequency.value = 0.1 + (distortion * 5);
        }

        function handleDialog(npc) {
            if(state.isDialog) return;
            state.isDialog = true;
            controls.unlock();
            
            const box = document.getElementById('dialog-box');
            const txt = document.getElementById('npc-text');
            const choices = document.getElementById('npc-choices');
            
            box.style.display = 'block';
            txt.innerText = npc.data.q;
            choices.innerHTML = '';
            
            npc.data.a.forEach(opt => {
                const btn = document.createElement('button');
                btn.className = 'choice-btn';
                btn.innerText = opt.t;
                btn.onclick = () => {
                    // Apply effects
                    if(opt.e.includes('hp-')) state.hp -= 20;
                    if(opt.e.includes('hp+')) state.hp = Math.min(100, state.hp + 20);
                    if(opt.e.includes('san-')) state.sanity -= 20;
                    if(opt.e.includes('san+')) state.sanity = Math.min(100, state.sanity + 20);
                    
                    npc.active = false; // Disable NPC
                    npc.sprite.material.color.setHex(0x555555); // Grey out
                    
                    closeDialog();
                };
                choices.appendChild(btn);
            });
        }

        function closeDialog() {
            document.getElementById('dialog-box').style.display = 'none';
            state.isDialog = false;
            controls.lock();
        }

        function gameOver(reason) {
            state.isPlaying = false;
            controls.unlock();
            const screen = document.getElementById('overlay-screen');
            screen.style.display = 'flex';
            screen.querySelector('h1').innerText = reason === 'win' ? "ASCENSION" : "TERMINATED";
            screen.querySelector('p').innerText = reason === 'win' ? 
                "YOU FOUND THE EXIT. BUT THE ARCHIVE REMAINS." : 
                "YOUR DATA HAS BEEN ASSIMILATED.";
            document.getElementById('start-btn').innerText = "REBOOT SYSTEM";
            
            if(droneOsc) {
                droneOsc.stop();
                noiseNode.stop();
            }
        }

        function startGame() {
            state = { hp: 100, sanity: 100, isPlaying: true, isDialog: false, level: state.level + 1 };
            document.getElementById('overlay-screen').style.display = 'none';
            
            generateMaze(config.mazeSize);
            spawnEntity();
            initAudio();
            
            controls.lock();
        }

        // --- MAIN LOOP ---
        const clock = new THREE.Clock();
        const playerVel = new THREE.Vector3();
        const direction = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);

            if (!state.isPlaying || state.isDialog) return;

            const delta = clock.getDelta();
            
            // 1. Player Movement
            playerVel.x -= playerVel.x * 10.0 * delta;
            playerVel.z -= playerVel.z * 10.0 * delta;

            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();

            if (moveForward || moveBackward) playerVel.z -= direction.z * 40.0 * delta;
            if (moveLeft || moveRight) playerVel.x -= direction.x * 40.0 * delta;

            controls.moveRight(-playerVel.x * delta * config.speed);
            controls.moveForward(-playerVel.z * delta * config.speed);

            // 2. Collision Detection (Simple Box Check)
            const pPos = camera.position;
            // Floor check
            const cx = Math.round(pPos.x / 2);
            const cy = Math.round(pPos.z / 2);
            
            // Check boundaries vs Maze Array
            if(cx >= 0 && cx < config.mazeSize && cy >= 0 && cy < config.mazeSize) {
                if(floorPlan[cy][cx] === 1) {
                    // Collision: Push back
                    controls.moveRight(playerVel.x * delta * config.speed);
                    controls.moveForward(playerVel.z * delta * config.speed);
                }
            }

            // 3. Entity Logic
            if(entity) {
                const dist = pPos.distanceTo(entity.position);
                
                // Move towards player
                const dirToPlayer = new THREE.Vector3().subVectors(pPos, entity.position).normalize();
                entity.position.add(dirToPlayer.multiplyScalar(config.entitySpeed * delta));
                
                // Constant look at
                entity.lookAt(pPos);

                // Sanity drain proximity
                if(dist < 8) {
                    state.sanity -= delta * 5;
                    // Audio flicker volume
                    gainNode.gain.value = 0.15 + (Math.random() * 0.5);
                } else {
                    gainNode.gain.value = 0.15;
                }

                // Jumpscare / Death
                if(dist < 1.2) {
                    gameOver('dead');
                }
            }

            // 4. Avant-Garde Objects Animation
            scene.children.forEach(child => {
                if(child.userData.floatOffset) {
                    child.rotation.x += child.userData.rotSpeed;
                    child.rotation.y += child.userData.rotSpeed;
                    child.position.y = 1.5 + Math.sin(clock.elapsedTime + child.userData.floatOffset) * 0.5;
                }
            });

            // 5. NPC Interaction
            npcs.forEach(npc => {
                if(npc.active && pPos.distanceTo(npc.sprite.position) < 2.5) {
                    handleDialog(npc);
                }
            });

            // 6. Win Condition
            if(pPos.distanceTo(exitPos) < 2) {
                gameOver('win');
            }

            // 7. Stats Check
            if(state.hp <= 0 || state.sanity <= 0) gameOver('dead');

            updateHUD();
            renderer.render(scene, camera);
        }

        // --- INPUT HANDLING ---
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;

        const onKeyDown = function (event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = true; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                case 'ArrowRight': case 'KeyD': moveRight = true; break;
            }
        };

        const onKeyUp = function (event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': moveForward = false; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                case 'ArrowRight': case 'KeyD': moveRight = false; break;
            }
        };

        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
        
        document.getElementById('start-btn').addEventListener('click', startGame);
        
        // Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth * config.resScale, window.innerHeight * config.resScale, false);
        });

        animate();

    </script>
</body>
</html>

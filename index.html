<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>GLITCH CITY: SECTOR 0</title>

  <!-- Fix favicon 404 (embedded) -->
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64'%3E%3Crect width='64' height='64' fill='black'/%3E%3Ctext x='8' y='44' font-size='32' fill='%23f00' font-family='monospace'%3E%3E_%3C/text%3E%3C/svg%3E">

  <style>
    body { margin:0; overflow:hidden; background:#000; font-family: "Courier New", monospace; }
    canvas { display:block; image-rendering: pixelated; }

    /* UI */
    #ui-layer { position:absolute; inset:0; pointer-events:none; z-index:10; }
    #crosshair{
      position:absolute; top:50%; left:50%; width:12px; height:12px;
      border:2px solid rgba(255,255,255,0.8); border-radius:50%;
      transform:translate(-50%,-50%); transition:0.15s;
      box-shadow:0 0 10px rgba(255,255,255,0.08);
    }
    .interact-active{ border-color:#0f0 !important; background:rgba(0,255,0,0.25); width:20px !important; height:20px !important; }

    #stats{ position:absolute; bottom:18px; left:18px; color:#fff; font-size:18px; text-shadow:2px 2px 0 #000; }
    .stat-bar{ width:220px; height:14px; background:#222; margin-top:6px; border:1px solid rgba(255,255,255,0.85); }
    .fill{ height:100%; transition:width 0.25s; }
    #hp-bar{ background:#c00; width:100%; }
    #san-bar{ background:#06c; width:100%; }

    #quest-log{ margin-top:10px; font-size:14px; color:#b5b5b5; max-width:360px; line-height:1.2; }

    #minimap-container{
      position:absolute; top:18px; right:18px;
      width:150px; height:150px; background:rgba(0,0,0,0.55);
      border:2px solid rgba(255,255,255,0.85); border-radius:50%; overflow:hidden;
      box-shadow:0 0 18px rgba(255,255,255,0.06);
    }
    #minimap{ width:100%; height:100%; opacity:0.85; }

    #interaction-text{
      position:absolute; top:61%; left:50%; transform:translateX(-50%);
      color:#ff0; font-size:20px; font-weight:bold; text-shadow:1px 1px 0 #000;
      display:none;
      background:rgba(0,0,0,0.35); padding:6px 10px; border:1px solid rgba(255,255,0,0.35);
    }

    /* overlays */
    #note-overlay{
      display:none; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%);
      width:min(520px, 92vw);
      background:#f8f8f8; color:#000; padding:18px 18px 14px;
      font-family: "Times New Roman", serif;
      border:10px solid #1a1a1a; box-shadow:0 0 50px rgba(0,0,0,0.95);
      pointer-events:auto; text-align:left;
    }
    #note-overlay h2{ margin:0 0 8px; font-size:22px; }
    #note-overlay p{ margin:0 0 12px; line-height:1.35; }

    #start-screen, #death-screen{
      position:absolute; inset:0; background:rgba(0,0,0,0.96);
      display:flex; flex-direction:column; justify-content:center; align-items:center;
      z-index:20; color:#fff; pointer-events:auto;
    }

    .panel{
      width:min(720px, 94vw);
      border:1px solid rgba(255,255,255,0.18);
      background:linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
      box-shadow:0 0 60px rgba(0,0,0,0.8);
      border-radius:14px;
      padding:22px;
    }
    .row{ display:flex; gap:14px; flex-wrap:wrap; align-items:center; }
    .row > * { flex: 1 1 auto; }

    label{ font-size:13px; color:#cfcfcf; display:block; margin:10px 0 6px; letter-spacing:0.5px; }
    input, select{
      pointer-events:auto;
      width:100%;
      padding:12px 12px;
      border-radius:10px;
      background:rgba(0,0,0,0.45);
      border:1px solid rgba(255,255,255,0.22);
      color:#fff;
      font-family:inherit;
      outline:none;
    }
    input:focus, select:focus{ border-color: rgba(255,0,0,0.55); box-shadow:0 0 0 3px rgba(255,0,0,0.12); }

    button{
      pointer-events:auto;
      padding:12px 18px;
      font-size:1.05em;
      background:#b00000; color:#fff;
      border:none; border-radius:12px;
      cursor:pointer;
      margin-top:14px;
      font-family:inherit;
      letter-spacing:0.5px;
      box-shadow:0 0 22px rgba(255,0,0,0.08);
    }
    button:hover{ background:#e00000; box-shadow:0 0 24px rgba(255,0,0,0.18); }
    .hint{ color:#bdbdbd; font-size:13px; line-height:1.35; margin-top:10px; }
    .title{
      font-size:54px; margin:0 0 10px;
      color:#ff2a2a; text-shadow: 0 0 30px rgba(255,0,0,0.18);
      letter-spacing:2px;
    }

    .glitch-text{ animation: glitch 0.28s infinite; display:inline-block; }
    @keyframes glitch{
      0%{ transform:translate(0); filter:hue-rotate(0deg); }
      20%{ transform:translate(-2px,2px); filter:hue-rotate(18deg); }
      40%{ transform:translate(-2px,-2px); filter:hue-rotate(40deg); }
      60%{ transform:translate(2px,2px); filter:hue-rotate(65deg); }
      80%{ transform:translate(2px,-2px); filter:hue-rotate(95deg); }
      100%{ transform:translate(0); filter:hue-rotate(0deg); }
    }

    /* "PS2" post look */
    #postFX {
      position:absolute; inset:0; z-index:9; pointer-events:none;
      mix-blend-mode: screen;
      opacity:0.22;
      background:
        repeating-linear-gradient(0deg, rgba(255,255,255,0.03), rgba(255,255,255,0.03) 1px, rgba(0,0,0,0) 3px, rgba(0,0,0,0) 5px);
      filter: blur(0.2px);
    }

    #subtitle {
      position:absolute; left:50%; bottom:120px; transform:translateX(-50%);
      color:#eaeaea;
      font-size:15px;
      text-shadow: 2px 2px 0 rgba(0,0,0,0.85);
      background: rgba(0,0,0,0.28);
      border: 1px solid rgba(255,255,255,0.12);
      padding:6px 10px;
      border-radius:10px;
      display:none;
      pointer-events:none;
      max-width:min(820px, 92vw);
      text-align:center;
    }
  </style>
</head>
<body>
  <div id="postFX"></div>

  <div id="ui-layer">
    <div id="crosshair"></div>
    <div id="minimap-container"><canvas id="minimap" width="150" height="150"></canvas></div>
    <div id="stats">
      <div>DATA INTEGRITY (HP)</div>
      <div class="stat-bar"><div id="hp-bar" class="fill"></div></div>
      <div>LOGIC STABILITY (SANITY)</div>
      <div class="stat-bar"><div id="san-bar" class="fill"></div></div>
      <div id="quest-log">OBJECTIVE: FIND THE SERVER ROOM KEY</div>
    </div>
    <div id="interaction-text">PRESS [E] TO INTERACT</div>
    <div id="subtitle"></div>
  </div>

  <div id="note-overlay">
    <h2 id="note-title">NOTE</h2>
    <p id="note-content">...</p>
    <button id="note-close">PUT AWAY</button>
  </div>

  <div id="start-screen">
    <div class="panel">
      <div class="title glitch-text">GLITCH CITY</div>
      <div style="font-size:14px; color:#cfcfcf; letter-spacing:1px;">SECTOR 0 // “RAIN OF DATA”</div>

      <div class="row" style="margin-top:14px;">
        <div>
          <label>YOUR NAME (used in corrupted TVs + messages)</label>
          <input id="playerName" maxlength="20" placeholder="e.g. DEFER, NAILMAN, UNKNOWN" value="UNKNOWN" />
        </div>
        <div>
          <label>MOUSE SENSITIVITY</label>
          <input id="sens" type="range" min="0.4" max="2.2" step="0.05" value="1.0"/>
        </div>
        <div>
          <label>SMOOTHING</label>
          <input id="smooth" type="range" min="0.02" max="0.25" step="0.01" value="0.12"/>
        </div>
      </div>

      <div class="row" style="margin-top:10px;">
        <div>
          <label>DIFFICULTY</label>
          <select id="difficulty">
            <option value="0">LOW SIGNAL</option>
            <option value="1" selected>DEFAULT</option>
            <option value="2">HARD CORRUPTION</option>
          </select>
        </div>
        <div>
          <label>AUDIO</label>
          <select id="audioMode">
            <option value="1" selected>OMINOUS (breathing + drone)</option>
            <option value="0">OFF</option>
          </select>
        </div>
        <div>
          <label>VOICE (TTS)</label>
          <select id="ttsMode">
            <option value="1" selected>ON</option>
            <option value="0">OFF</option>
          </select>
        </div>
      </div>

      <div class="hint">
        WASD Move • SHIFT Run • SPACE Jump • E Interact • ESC Pause/Unlock<br/>
        Find the key. Don’t stare at the things that know your name.
      </div>

      <button id="start-btn">ENTER SIMULATION</button>
    </div>
  </div>

  <div id="death-screen" style="display:none;">
    <div class="panel" style="text-align:center;">
      <h1 style="color:#ff3b3b; margin:0 0 8px;">CONNECTION LOST</h1>
      <p id="death-reason" style="color:#cfcfcf; margin:0 0 14px;"></p>
      <button onclick="location.reload()">RESPAWN</button>
    </div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from "three";

    // =============================
    // CONFIG + STATE
    // =============================
    const config = {
      mapSize: 40,
      scale: 4,
      enemyCount: 7,
      itemCount: 14,
      tvCount: 10,
      fog: 0.045
    };

    const state = {
      hp: 100,
      sanity: 100,
      isPlaying: false,
      glitchMode: 0,
      level: 1,
      playerName: "UNKNOWN",
      keyFound: false,
      difficulty: 1,
      audioOn: true,
      ttsOn: true
    };

    const ui = {
      hp: document.getElementById("hp-bar"),
      san: document.getElementById("san-bar"),
      quest: document.getElementById("quest-log"),
      crosshair: document.getElementById("crosshair"),
      interactText: document.getElementById("interaction-text"),
      subtitle: document.getElementById("subtitle"),
      note: document.getElementById("note-overlay"),
      noteTitle: document.getElementById("note-title"),
      noteContent: document.getElementById("note-content")
    };

    function setSubtitle(text, ms=2200){
      ui.subtitle.style.display = "block";
      ui.subtitle.textContent = text;
      clearTimeout(setSubtitle._t);
      setSubtitle._t = setTimeout(() => ui.subtitle.style.display="none", ms);
    }

    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

    // =============================
    // TEXTURES (procedural)
    // =============================
    const textures = {};
    function createTexture(type, color1, color2) {
      const size = 512;
      const canvas = document.createElement("canvas");
      canvas.width = size; canvas.height = size;
      const ctx = canvas.getContext("2d");

      ctx.fillStyle = color1;
      ctx.fillRect(0,0,size,size);

      if (type === "noise") {
        ctx.globalAlpha = 0.12;
        for (let i=0;i<12000;i++){
          ctx.fillStyle = Math.random() > 0.55 ? color2 : "#000";
          ctx.fillRect(Math.random()*size, Math.random()*size, 2, 2);
        }
        ctx.globalAlpha = 1;
      } else if (type === "brick") {
        ctx.fillStyle = color1;
        ctx.fillRect(0,0,size,size);
        ctx.strokeStyle = color2;
        ctx.lineWidth = 4;
        for(let y=0;y<size;y+=64){
          for(let x=0;x<size;x+=128){
            const offset = (y/64)%2===0 ? 0 : 64;
            ctx.strokeRect(x+offset, y, 128, 64);
            if(Math.random()>0.45){
              ctx.fillStyle = "rgba(0,0,0,0.22)";
              ctx.fillRect(x+offset+10, y+10, 100, 40);
            }
          }
        }
      } else if (type === "wood") {
        ctx.fillStyle = color1; ctx.fillRect(0,0,size,size);
        ctx.strokeStyle = color2;
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.65;
        for(let i=0;i<size;i+=4){
          ctx.beginPath();
          ctx.moveTo(0, i + Math.random()*8);
          ctx.lineTo(size, i + Math.random()*8);
          ctx.stroke();
        }
        ctx.globalAlpha = 1;
      } else if (type === "static") {
        for(let i=0;i<65000;i++){
          ctx.fillStyle = `rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},1)`;
          ctx.fillRect(Math.random()*size, Math.random()*size, 2, 2);
        }
      }
      const tex = new THREE.CanvasTexture(canvas);
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      tex.anisotropy = 2;
      return tex;
    }

    textures.concrete = createTexture("noise", "#3a3a3a", "#1b1b1b");
    textures.brick    = createTexture("brick", "#4a2020", "#2a1010");
    textures.wood     = createTexture("wood", "#4b2a18", "#26160c");
    textures.grass    = createTexture("noise", "#0f1f12", "#061108");
    textures.static   = createTexture("static", "#000", "#fff");

    // =============================
    // THREE SETUP (PS2-ish look)
    // =============================
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x04040b);
    scene.fog = new THREE.FogExp2(0x04040b, config.fog);

    const camera = new THREE.PerspectiveCamera(72, innerWidth/innerHeight, 0.08, 120);
    camera.position.set(5, 1.7, 5);

    const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 1.4));
    renderer.shadowMap.enabled = false; // PS2 vibe
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    // lighting (moody)
    scene.add(new THREE.HemisphereLight(0x3b3b55, 0x0a0a12, 0.38));
    const moon = new THREE.DirectionalLight(0xaabbee, 0.22);
    moon.position.set(40, 80, 30);
    scene.add(moon);

    // flashlight cone
    const flash = new THREE.SpotLight(0xfff3d8, 1.8, 38, Math.PI/6, 0.62, 1);
    flash.position.set(0,0,0);
    flash.target.position.set(0,0,-1);
    camera.add(flash); camera.add(flash.target);
    scene.add(camera);

    // =============================
    // CUSTOM POINTER LOCK (stable)
    // =============================
    const yawObject = new THREE.Object3D();
    const pitchObject = new THREE.Object3D();
    yawObject.position.copy(camera.position);
    pitchObject.add(camera);
    yawObject.add(pitchObject);
    scene.add(yawObject);

    let isLocked = false;
    let targetYaw = 0, targetPitch = 0;
    let yaw = 0, pitch = 0;
    let sens = 1.0, smoothing = 0.12;

    function requestLock(){
      renderer.domElement.requestPointerLock({ unadjustedMovement: true });
    }

    document.addEventListener("pointerlockchange", () => {
      isLocked = (document.pointerLockElement === renderer.domElement);
      if(!isLocked && state.isPlaying){
        setSubtitle("SIGNAL PAUSED. CLICK TO RESUME.", 1800);
      }
    });

    document.addEventListener("mousemove", (e) => {
      if(!isLocked || !state.isPlaying) return;
      const mx = e.movementX || 0;
      const my = e.movementY || 0;

      const s = 0.0022 * sens;
      targetYaw   -= mx * s;
      targetPitch -= my * s;

      const maxPitch = Math.PI/2.25;
      targetPitch = clamp(targetPitch, -maxPitch, maxPitch);
    });

    // =============================
    // WORLD / ENTITIES
    // =============================
    const colliders = [];
    const interactables = [];
    const enemies = [];
    const tvScreens = [];

    const map = []; // for minimap marking

    function clearWorld(){
      // brute remove everything except camera rig + lights
      const keep = new Set([yawObject, camera]);
      const toRemove = [];
      scene.traverse((obj) => {
        if(obj.isMesh || obj.isPoints || obj.isSprite){
          // don't remove camera children
          if(obj !== renderer.domElement && !keep.has(obj) && obj.parent && obj.parent !== camera){
            toRemove.push(obj);
          }
        }
      });
      toRemove.forEach(o => { if(o.parent) o.parent.remove(o); });
      colliders.length = 0; interactables.length=0; enemies.length=0; tvScreens.length=0;
      for(let i=0;i<config.mapSize;i++){ map[i] = Array(config.mapSize).fill(0); }
    }

    function generateCity(){
      clearWorld();

      // Ground
      const planeGeo = new THREE.PlaneGeometry(config.mapSize*config.scale, config.mapSize*config.scale, 1, 1);
      const planeMat = new THREE.MeshStandardMaterial({ map: textures.grass, roughness: 1 });
      planeMat.map.repeat.set(8,8);
      const ground = new THREE.Mesh(planeGeo, planeMat);
      ground.rotation.x = -Math.PI/2;
      ground.position.set(config.mapSize*config.scale/2, 0, config.mapSize*config.scale/2);
      scene.add(ground);

      // Roads grid (for vibe + navigation)
      const roadMat = new THREE.MeshStandardMaterial({ color: 0x0c0c12, roughness: 1 });
      for(let x=2; x<config.mapSize; x+=4){
        for(let z=0; z<config.mapSize; z++){
          map[x][z] = 1;
          const tile = new THREE.Mesh(new THREE.BoxGeometry(config.scale, 0.08, config.scale), roadMat);
          tile.position.set(x*config.scale, 0.04, z*config.scale);
          scene.add(tile);
        }
      }
      for(let z=2; z<config.mapSize; z+=4){
        for(let x=0; x<config.mapSize; x++){
          map[x][z] = 1;
          const tile = new THREE.Mesh(new THREE.BoxGeometry(config.scale, 0.08, config.scale), roadMat);
          tile.position.set(x*config.scale, 0.04, z*config.scale);
          scene.add(tile);
        }
      }

      // Populate blocks
      for(let x=0;x<config.mapSize;x++){
        for(let z=0;z<config.mapSize;z++){
          const wx = x*config.scale, wz = z*config.scale;
          if(map[x][z] === 0){
            const r = Math.random();
            if(r > 0.72) spawnBuilding(wx, wz);
            else if (r > 0.52) spawnAsylumProp(wx, wz);
            else if (r > 0.46) spawnTree(wx, wz);
            else if (r > 0.40) spawnBrokenTV(wx, wz);
          }
        }
      }

      // Boundaries (simple invisible walls)
      const W = config.mapSize*config.scale;
      const wallMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
      const wallGeoX = new THREE.BoxGeometry(W, 20, 1);
      const wallGeoZ = new THREE.BoxGeometry(1, 20, W);

      const w1 = new THREE.Mesh(wallGeoX, wallMat); w1.position.set(W/2, 10, -1); scene.add(w1); colliders.push(w1);
      const w2 = new THREE.Mesh(wallGeoX, wallMat); w2.position.set(W/2, 10, W+1); scene.add(w2); colliders.push(w2);
      const w3 = new THREE.Mesh(wallGeoZ, wallMat); w3.position.set(-1, 10, W/2); scene.add(w3); colliders.push(w3);
      const w4 = new THREE.Mesh(wallGeoZ, wallMat); w4.position.set(W+1, 10, W/2); scene.add(w4); colliders.push(w4);

      // Goal: server door + key
      spawnServerDoor(10, 10);
      spawnKey(26, 28);

      // Notes / food
      for(let i=0;i<config.itemCount;i++){
        const rx = Math.floor(Math.random()*config.mapSize)*config.scale;
        const rz = Math.floor(Math.random()*config.mapSize)*config.scale;
        if(Math.random()>0.55) spawnFood(rx, rz, Math.random()>0.72);
        else spawnNote(rx, rz, "LOG "+i, corruptText(`It said: ${state.playerName}. I didn't type it.`));
      }

      // TVs that print your name
      for(let i=0;i<config.tvCount;i++){
        const rx = Math.floor(Math.random()*config.mapSize)*config.scale;
        const rz = Math.floor(Math.random()*config.mapSize)*config.scale;
        spawnBrokenTV(rx, rz, true);
      }

      // Enemies (png-like sprites)
      const baseCount = config.enemyCount + (state.difficulty===2 ? 4 : state.difficulty===0 ? -2 : 0);
      for(let i=0;i<Math.max(3, baseCount); i++){
        spawnEnemySprite();
      }

      ui.quest.textContent = "OBJECTIVE: FIND THE SERVER ROOM KEY";
      setSubtitle(`WELCOME, ${state.playerName}.`, 1800);
      speak(`Welcome, ${state.playerName}. The sector is corrupted. Find the key.`, 320);
    }

    function spawnBuilding(x,z){
      const h = 5 + Math.random()*12;
      const geo = new THREE.BoxGeometry(3, h, 3);
      const mat = new THREE.MeshStandardMaterial({ map: textures.brick, roughness: 1 });
      mat.map.repeat.set(1, 1);
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.set(x, h/2, z);
      scene.add(mesh);
      colliders.push(mesh);
    }

    function spawnAsylumProp(x,z){
      // simple “asylum debris”: bed frame or cabinet
      const kind = Math.random() > 0.5 ? "bed" : "cabinet";
      const mat = new THREE.MeshStandardMaterial({ map: textures.concrete, color: kind==="bed" ? 0x2a2a33 : 0x232326, roughness: 1 });

      if(kind==="bed"){
        const base = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.35, 1.2), mat);
        base.position.set(x, 0.22, z);
        const rail = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.7, 0.12), mat);
        rail.position.set(0, 0.55, 0.55);
        base.add(rail);
        scene.add(base);
        colliders.push(base);
      }else{
        const cab = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.5, 0.7), mat);
        cab.position.set(x, 0.75, z);
        scene.add(cab);
        colliders.push(cab);
      }
    }

    function spawnTree(x,z){
      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.25, 0.35, 3, 6),
        new THREE.MeshStandardMaterial({ map: textures.wood, roughness: 1 })
      );
      trunk.position.set(x, 1.5, z);
      const leaves = new THREE.Mesh(
        new THREE.ConeGeometry(1.8, 3.6, 7),
        new THREE.MeshStandardMaterial({ color: 0x17301d, roughness: 1 })
      );
      leaves.position.y = 2.4;
      trunk.add(leaves);
      scene.add(trunk);
      colliders.push(trunk);
    }

    // Corrupted text helper (avant-garde)
    function corruptText(s){
      const salt = ["▒","░","█","⟟","⟒","⏃","⏁","⎅","⌁","⧗","⨂","⫷","⫸"];
      return s.split("").map(ch => Math.random()<0.12 ? salt[(Math.random()*salt.length)|0] : ch).join("");
    }

    // TV texture with your name + flicker
    function makeTVTexture(label){
      const c = document.createElement("canvas");
      c.width = 256; c.height = 192;
      const ctx = c.getContext("2d");
      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;

      let t = 0;
      function draw(){
        t += 1;
        ctx.fillStyle = "#0a0a0a";
        ctx.fillRect(0,0,c.width,c.height);

        // scan noise
        for(let i=0;i<2200;i++){
          const v = (Math.random()*255)|0;
          ctx.fillStyle = `rgba(${v},${v},${v},${Math.random()*0.18})`;
          ctx.fillRect(Math.random()*c.width, Math.random()*c.height, 1, 1);
        }

        // text band
        ctx.fillStyle = "rgba(255,0,0,0.08)";
        ctx.fillRect(0, 40 + (Math.sin(t*0.12)*14), c.width, 42);

        ctx.font = "18px monospace";
        ctx.fillStyle = "rgba(255,255,255,0.92)";
        ctx.fillText(corruptText(label), 10, 85);

        ctx.font = "12px monospace";
        ctx.fillStyle = "rgba(255,255,0,0.88)";
        ctx.fillText(corruptText(">> DO NOT REMEMBER"), 10, 110);
        ctx.fillStyle = "rgba(160,200,255,0.75)";
        ctx.fillText(corruptText(`ID: ${state.playerName}`), 10, 132);

        // rolling line
        ctx.fillStyle = "rgba(255,255,255,0.12)";
        ctx.fillRect(0, (t*3)%c.height, c.width, 2);

        tex.needsUpdate = true;
      }
      return { tex, draw };
    }

    function spawnBrokenTV(x,z, talks=false){
      const tv = new THREE.Mesh(
        new THREE.BoxGeometry(1, 0.8, 0.8),
        new THREE.MeshStandardMaterial({ color: 0x2a2a2f, roughness: 1 })
      );
      tv.position.set(x, 0.4, z);

      const screen = new THREE.Mesh(
        new THREE.PlaneGeometry(0.86, 0.62),
        new THREE.MeshBasicMaterial({ map: textures.static })
      );
      screen.position.z = 0.41;
      tv.add(screen);

      const label = `${state.playerName} // SECTOR 0`;
      const tvTex = makeTVTexture(label);
      const tvMat = new THREE.MeshBasicMaterial({ map: tvTex.tex });
      const overlay = new THREE.Mesh(new THREE.PlaneGeometry(0.84, 0.60), tvMat);
      overlay.position.z = 0.412;
      tv.add(overlay);
      tvScreens.push(tvTex);

      const light = new THREE.PointLight(0x99ddff, 0.55, 3.2);
      light.position.set(0,0,1);
      tv.add(light);

      scene.add(tv);
      colliders.push(tv);

      if(talks){
        interactables.push({
          mesh: tv,
          text: "LISTEN",
          action: () => {
            const lines = [
              `Hello, ${state.playerName}.`,
              `Your name is already in the walls.`,
              `Do not trust the breathing.`,
              `If you see yourself, run.`
            ];
            const l = lines[(Math.random()*lines.length)|0];
            setSubtitle(corruptText(l), 2600);
            speak(l, 250);
            // TV glitch pulse
            state.glitchMode = 1;
            setTimeout(()=>state.glitchMode=0, 1100);
          }
        });
      }
    }

    function spawnFood(x,z,isRotten){
      const mesh = new THREE.Mesh(
        new THREE.DodecahedronGeometry(0.32),
        new THREE.MeshStandardMaterial({ color: isRotten ? 0x00ff66 : 0xffaa22, emissive: 0x111111, roughness: 0.9 })
      );
      mesh.position.set(x, 0.5, z);
      scene.add(mesh);

      interactables.push({
        mesh,
        text: isRotten ? "EAT GLITCHED MEAT" : "EAT DATA PACK",
        action: () => {
          scene.remove(mesh);
          if(isRotten){
            state.glitchMode = 2;
            state.sanity -= 22;
            setSubtitle("YOUR THOUGHTS DESYNC.", 1700);
            speak("Your thoughts are desynchronizing.", 200);
            setTimeout(()=> state.glitchMode = 0, 5200);
          } else {
            state.hp = Math.min(100, state.hp + 18);
            state.sanity = Math.min(100, state.sanity + 10);
            setSubtitle("STABILIZED.", 900);
          }
          syncBars();
        }
      });
    }

    function spawnNote(x,z,title,content){
      const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(0.55, 0.7),
        new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide })
      );
      mesh.rotation.x = -Math.PI/2;
      mesh.position.set(x, 0.05, z);
      scene.add(mesh);

      interactables.push({
        mesh,
        text: "READ NOTE",
        action: () => {
          ui.note.style.display = "block";
          ui.noteTitle.textContent = title;
          ui.noteContent.textContent = content;
          unlockPointer(); // let user click
          setSubtitle("READING...", 900);
          if(state.ttsOn) speak(content.slice(0, 120), 120);
        }
      });
    }

    function spawnKey(x,z){
      const mesh = new THREE.Mesh(
        new THREE.TorusKnotGeometry(0.22, 0.08, 60, 10),
        new THREE.MeshStandardMaterial({ color: 0xffe066, emissive: 0x332200, roughness: 0.4, metalness: 0.8 })
      );
      mesh.position.set(x, 0.75, z);
      scene.add(mesh);

      interactables.push({
        mesh,
        text: "TAKE KEY",
        action: () => {
          scene.remove(mesh);
          state.keyFound = true;
          ui.quest.textContent = "OBJECTIVE: RETURN TO THE SERVER DOOR";
          setSubtitle("KEY ACQUIRED.", 1500);
          speak(`Key acquired. Return to the server door, ${state.playerName}.`, 220);
          // small sanity hit (keys feel wrong)
          state.sanity -= 6;
          syncBars();
        }
      });
    }

    function spawnServerDoor(x,z){
      const door = new THREE.Mesh(
        new THREE.BoxGeometry(2.2, 4.2, 0.2),
        new THREE.MeshStandardMaterial({ map: textures.wood, color: 0x3b2a2a, roughness: 1 })
      );
      door.position.set(x, 2.1, z);
      scene.add(door);
      colliders.push(door);

      // frame light
      const glow = new THREE.PointLight(0xff3355, 0.55, 6);
      glow.position.set(x, 2.1, z-1.2);
      scene.add(glow);

      interactables.push({
        mesh: door,
        text: "ACCESS SERVER ROOM",
        action: () => {
          if(!state.keyFound){
            setSubtitle("LOCKED. YOU NEED THE KEY.", 1600);
            speak("Locked. You need the key.", 200);
            state.sanity -= 2;
            syncBars();
            return;
          }
          // win-ish sequence
          setSubtitle("DOOR ACCEPTS YOU.", 2000);
          speak(`Access granted, ${state.playerName}. Do not look back.`, 260);
          ui.quest.textContent = "OBJECTIVE: STEP THROUGH.";
          // open animation
          const start = performance.now();
          const openAnim = () => {
            const t = (performance.now()-start)/900;
            door.rotation.y = -clamp(t,0,1) * (Math.PI/2);
            if(t<1) requestAnimationFrame(openAnim);
            else {
              // fade out / end
              state.isPlaying = false;
              unlockPointer();
              document.getElementById("death-screen").style.display = "flex";
              document.getElementById("death-reason").textContent = "SIMULATION COMPLETE // MEMORY PURGE INITIATED";
            }
          };
          openAnim();
        }
      });
    }

    // =============================
    // CREEPY SPRITE MONSTERS (PNG-like)
    // =============================
    function makeCreepyPNG(seed=0){
      const c = document.createElement("canvas");
      c.width = 256; c.height = 256;
      const ctx = c.getContext("2d");

      // background alpha (transparent)
      ctx.clearRect(0,0,256,256);

      // blob silhouette
      ctx.fillStyle = "rgba(0,0,0,0.85)";
      ctx.beginPath();
      const cx = 128, cy = 140;
      for(let a=0;a<Math.PI*2; a+=0.2){
        const r = 64 + 18*Math.sin(a*3 + seed) + 10*Math.random();
        ctx.lineTo(cx + Math.cos(a)*r, cy + Math.sin(a)*r*1.15);
      }
      ctx.closePath();
      ctx.fill();

      // eyes
      const eyeY = 110 + (Math.random()*10-5);
      const eyeX = 64 + (Math.random()*16-8);
      ctx.fillStyle = "rgba(255,0,0,0.95)";
      ctx.fillRect(128-eyeX-18, eyeY, 18, 8);
      ctx.fillRect(128+eyeX,     eyeY, 18, 8);

      // mouth
      ctx.fillStyle = "rgba(255,255,255,0.85)";
      ctx.fillRect(96 + (Math.random()*8-4), 150, 64, 6);

      // noise scratches
      for(let i=0;i<1200;i++){
        const v = (Math.random()*255)|0;
        ctx.fillStyle = `rgba(${v},${v},${v},${Math.random()*0.10})`;
        ctx.fillRect(Math.random()*256, Math.random()*256, 1, 1);
      }

      // vignette
      const g = ctx.createRadialGradient(128,128,40,128,128,140);
      g.addColorStop(0, "rgba(0,0,0,0)");
      g.addColorStop(1, "rgba(0,0,0,0.65)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,256,256);

      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      return tex;
    }

    function spawnEnemySprite(){
      const tex = makeCreepyPNG(Math.random()*10);
      const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
      const sprite = new THREE.Sprite(mat);
      sprite.scale.set(1.6, 2.2, 1);
      sprite.position.set(Math.random()*config.mapSize*config.scale, 1.2, Math.random()*config.mapSize*config.scale);
      scene.add(sprite);

      const speed = 1.6 + Math.random()*1.6 + (state.difficulty===2 ? 0.8 : 0);
      enemies.push({
        mesh: sprite,
        speed,
        phase: Math.random()*10,
        // for proximity TTS cooldown
        lastWhisper: 0
      });
    }

    // =============================
    // RAIN (lightweight)
    // =============================
    const rainCount = 6000;
    const rainGeo = new THREE.BufferGeometry();
    const rainPos = new Float32Array(rainCount*3);
    const R = config.mapSize*config.scale + 40;
    for(let i=0;i<rainPos.length;i+=3){
      rainPos[i]   = Math.random()*R - 20;
      rainPos[i+1] = Math.random()*70 + 5;
      rainPos[i+2] = Math.random()*R - 20;
    }
    rainGeo.setAttribute("position", new THREE.BufferAttribute(rainPos, 3));
    const rain = new THREE.Points(rainGeo, new THREE.PointsMaterial({ color: 0xaaaaaa, size: 0.08, transparent: true, opacity: 0.65 }));
    scene.add(rain);

    function updateWeather(){
      const p = rain.geometry.attributes.position.array;
      for(let i=1;i<p.length;i+=3){
        p[i] -= 0.7;
        if(p[i] < 0) p[i] = 70;
      }
      rain.geometry.attributes.position.needsUpdate = true;
      // rare lightning flash
      if(Math.random() > 0.996){
        scene.fog.density = config.fog * 0.6;
        setTimeout(()=> scene.fog.density = config.fog, 120);
      }
    }

    // =============================
    // MINIMAP
    // =============================
    const mapCanvas = document.getElementById("minimap");
    const mapCtx = mapCanvas.getContext("2d");
    function updateMinimap(){
      mapCtx.clearRect(0,0,150,150);
      mapCtx.fillStyle = "rgba(0,0,0,0.65)";
      mapCtx.fillRect(0,0,150,150);

      const px = yawObject.position.x;
      const pz = yawObject.position.z;
      const scale = 1.7;

      // player
      mapCtx.fillStyle = "#00ff66";
      mapCtx.beginPath();
      mapCtx.arc(75,75,4,0,Math.PI*2);
      mapCtx.fill();

      // enemies
      mapCtx.fillStyle = "#ff3b3b";
      enemies.forEach(e => {
        const rx = (e.mesh.position.x - px)*scale + 75;
        const ry = (e.mesh.position.z - pz)*scale + 75;
        if(rx>0 && rx<150 && ry>0 && ry<150) mapCtx.fillRect(rx-2, ry-2, 4, 4);
      });

      // colliders
      mapCtx.fillStyle = "rgba(255,255,255,0.25)";
      colliders.forEach(c => {
        const rx = (c.position.x - px)*scale + 75;
        const ry = (c.position.z - pz)*scale + 75;
        if(rx>0 && rx<150 && ry>0 && ry<150) mapCtx.fillRect(rx-1.5, ry-1.5, 3, 3);
      });
    }

    // =============================
    // INTERACTION (raycast)
    // =============================
    const raycaster = new THREE.Raycaster();
    let currentTarget = null;

    function checkInteraction(){
      raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
      const meshes = interactables.map(i => i.mesh);
      const hits = raycaster.intersectObjects(meshes, true);
      if(hits.length && hits[0].distance < 3.8){
        const obj = hits[0].object;
        const data = interactables.find(i => i.mesh === obj || i.mesh === obj.parent);
        if(data){
          ui.crosshair.classList.add("interact-active");
          ui.interactText.style.display = "block";
          ui.interactText.textContent = "[E] " + data.text;
          currentTarget = data;
          return;
        }
      }
      ui.crosshair.classList.remove("interact-active");
      ui.interactText.style.display = "none";
      currentTarget = null;
    }

    // =============================
    // MOVEMENT + COLLISION
    // =============================
    const clock = new THREE.Clock();
    const vel = new THREE.Vector3();
    const dir = new THREE.Vector3();
    let moveF=false, moveB=false, moveL=false, moveR=false, running=false;
    let canJump=false;

    function getMoveSpeed(){
      const base = running ? 6.3 : 4.4;
      const diff = state.difficulty===2 ? 0.95 : state.difficulty===0 ? 1.05 : 1.0;
      const sanityFactor = 0.75 + (state.sanity/100)*0.35;
      return base * diff * sanityFactor;
    }

    function resolveCollisions(prevPos){
      // cheap collision: if inside any collider AABB, revert
      const p = yawObject.position;
      for(const c of colliders){
        const box = new THREE.Box3().setFromObject(c);
        box.expandByScalar(0.35);
        if(box.containsPoint(p)){
          p.copy(prevPos);
          return;
        }
      }
    }

    // =============================
    // GLITCH / PS2 ARTIFACTS
    // =============================
    function applyGlitchFX(time){
      const canvas = renderer.domElement;

      if(state.glitchMode === 2){
        canvas.style.filter = `contrast(1.15) saturate(1.4) hue-rotate(${(Math.random()*360)|0}deg) invert(1)`;
      } else if(state.glitchMode === 1){
        canvas.style.filter = `contrast(1.12) saturate(1.2) hue-rotate(${(time*35)%360}deg)`;
      } else {
        // sanity low -> mild wobble color
        if(state.sanity < 35){
          canvas.style.filter = `contrast(1.08) saturate(1.15) hue-rotate(${(time*18)%360}deg)`;
        } else canvas.style.filter = "none";
      }

      // camera wobble only when sanity is low (keeps mouse stable)
      const wob = (state.sanity < 40) ? (0.0025 * (40 - state.sanity)) : 0;
      pitchObject.rotation.z = Math.sin(time*3.0) * wob;
    }

    // =============================
    // ENEMY AI (sprite chasers)
    // =============================
    function updateEnemies(delta, time){
      const p = yawObject.position;
      enemies.forEach(e => {
        const m = e.mesh;
        const d = m.position.distanceTo(p);

        // floaty drift
        m.position.y = 1.15 + Math.sin(time*2.2 + e.phase)*0.08;

        // face player
        // Sprites always face camera; but we can jitter scale for unease
        const pulse = 1 + Math.sin(time*6 + e.phase)*0.03;
        m.scale.set(1.6*pulse, 2.2*pulse, 1);

        if(d < 22){
          // chase
          const v = new THREE.Vector3().subVectors(p, m.position);
          v.y = 0;
          v.normalize();
          m.position.addScaledVector(v, e.speed * delta);

          // proximity damage
          if(d < 1.7){
            const dmg = (state.difficulty===2 ? 14 : 10) * delta;
            state.hp -= dmg;
            state.sanity -= (state.difficulty===2 ? 10 : 6) * delta;
            syncBars();
            state.glitchMode = 1;
          }

          // whisper TTS sometimes
          if(state.ttsOn && d < 8){
            if(time - e.lastWhisper > 7 + Math.random()*4){
              e.lastWhisper = time;
              const w = [
                `${state.playerName}...`,
                `You left something in the rain.`,
                `Look at me.`,
                `Do you remember your own face?`
              ][(Math.random()*4)|0];
              speak(w, 80);
              setSubtitle(corruptText(w), 1400);
            }
          }
        } else {
          // wander
          m.position.x += Math.sin(time*0.6 + e.phase) * 0.18 * delta;
          m.position.z += Math.cos(time*0.55 + e.phase) * 0.18 * delta;
        }
      });
    }

    function syncBars(){
      state.hp = clamp(state.hp, 0, 100);
      state.sanity = clamp(state.sanity, 0, 100);
      ui.hp.style.width = state.hp + "%";
      ui.san.style.width = state.sanity + "%";
      if(state.hp <= 0 || state.sanity <= 0) die();
    }

    function die(){
      state.isPlaying = false;
      unlockPointer();
      document.getElementById("death-screen").style.display = "flex";
      document.getElementById("death-reason").textContent =
        state.hp <= 0 ? "PHYSICAL TRAUMA CRITICAL" : "SYSTEM CORRUPTION 100%";
      speak("Connection lost.", 0);
    }

    // =============================
    // AUDIO: AudioWorklet (no ScriptProcessorNode)
    // =============================
    let audio = null;
    async function ensureAudio(){
      if(!state.audioOn) return;
      if(audio) return;

      const ctx = new (window.AudioContext || window.webkitAudioContext)();

      // AudioWorklet processor source (inline)
      const workletCode = `
      class OminousProcessor extends AudioWorkletProcessor {
        constructor(){
          super();
          this.t = 0;
          this.phase = 0;
          this.bPhase = 0;
          this.noiseSeed = 1;
          this.breath = 0;
          this.gain = 0.22;
          this.targetGain = 0.22;
          this.whine = 0.0;
          this.port.onmessage = (e)=>{
            const d = e.data || {};
            if(d.gain !== undefined) this.targetGain = d.gain;
            if(d.whine !== undefined) this.whine = d.whine;
          };
        }
        rnd(){
          // simple LCG
          this.noiseSeed = (this.noiseSeed * 1664525 + 1013904223) >>> 0;
          return (this.noiseSeed / 4294967296) * 2 - 1;
        }
        process(inputs, outputs){
          const out = outputs[0];
          const ch0 = out[0];
          const sr = sampleRate;

          // slew
          this.gain += (this.targetGain - this.gain) * 0.002;

          for(let i=0;i<ch0.length;i++){
            this.t++;

            // Drone (two detuned sines)
            const tt = this.t / sr;
            const drone = Math.sin(tt * 2*Math.PI * (45 + 0.5*Math.sin(tt*0.25)))
                        + 0.55*Math.sin(tt * 2*Math.PI * 57.3);

            // Breathing envelope (slow, organic)
            this.bPhase += 2*Math.PI * (0.095 + 0.02*Math.sin(tt*0.07)) / sr;
            const breathEnv = 0.5 + 0.5*Math.sin(this.bPhase);
            const breath = (this.rnd()*0.65 + Math.sin(tt*2*Math.PI*110)*0.15) * (breathEnv*breathEnv) * 0.8;

            // Noise layer (filtered-ish by moving average)
            const n = this.rnd();
            this.breath = this.breath*0.96 + n*0.04;
            const noise = this.breath * 0.55;

            // "radio whine" (controlled)
            const wh = this.whine;
            const whine = wh > 0 ? Math.sin(tt*2*Math.PI*(800 + 600*Math.sin(tt*0.9))) * wh * 0.25 : 0;

            // mix
            let s = (drone*0.22) + (noise*0.22) + (breath*0.28) + whine;

            // soft clip
            s = Math.tanh(s);

            ch0[i] = s * this.gain;
          }

          // mono -> stereo if needed
          if(out.length > 1){
            const ch1 = out[1];
            for(let i=0;i<ch1.length;i++) ch1[i] = ch0[i];
          }
          return true;
        }
      }
      registerProcessor('ominous-processor', OminousProcessor);
      `;

      const blob = new Blob([workletCode], { type: "application/javascript" });
      const url = URL.createObjectURL(blob);
      await ctx.audioWorklet.addModule(url);
      URL.revokeObjectURL(url);

      const node = new AudioWorkletNode(ctx, "ominous-processor", { numberOfInputs: 0, numberOfOutputs: 1, outputChannelCount: [2] });

      // slight reverb-ish space using delay feedback (simple + cheap)
      const delay = ctx.createDelay(0.25);
      delay.delayTime.value = 0.19;
      const fb = ctx.createGain(); fb.gain.value = 0.18;
      const tone = ctx.createBiquadFilter(); tone.type = "lowpass"; tone.frequency.value = 1600;

      node.connect(delay);
      delay.connect(tone);
      tone.connect(fb);
      fb.connect(delay);

      const mix = ctx.createGain(); mix.gain.value = 0.7;
      node.connect(mix);
      tone.connect(mix);
      mix.connect(ctx.destination);

      audio = { ctx, node };
    }

    function setAudioIntensity(v){
      if(!audio) return;
      audio.node.port.postMessage({ gain: clamp(v, 0, 0.38) });
    }
    function setAudioWhine(v){
      if(!audio) return;
      audio.node.port.postMessage({ whine: clamp(v, 0, 1) });
    }

    // =============================
    // REAL-TIME TTS
    // =============================
    function speak(text, delayMs=0){
      if(!state.ttsOn) return;
      // best effort: cancel stacking if too many
      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(text);
      u.rate = 0.98;
      u.pitch = 0.85;
      u.volume = 0.85;
      setTimeout(()=> window.speechSynthesis.speak(u), delayMs);
    }

    // =============================
    // MAIN LOOP
    // =============================
    function animate(){
      requestAnimationFrame(animate);
      if(!state.isPlaying) return;

      const delta = Math.min(0.04, clock.getDelta());
      const time = clock.getElapsedTime();

      // Smooth mouse (lerp)
      yaw += (targetYaw - yaw) * smoothing;
      pitch += (targetPitch - pitch) * smoothing;
      yawObject.rotation.y = yaw;
      pitchObject.rotation.x = pitch;

      // Weather + tv draw
      updateWeather();
      tvScreens.forEach(t => t.draw());
      updateMinimap();

      // movement
      if(isLocked){
        const prev = yawObject.position.clone();

        dir.set(0,0,0);
        if(moveF) dir.z -= 1;
        if(moveB) dir.z += 1;
        if(moveL) dir.x -= 1;
        if(moveR) dir.x += 1;
        if(dir.lengthSq() > 0) dir.normalize();

        const speed = getMoveSpeed();
        // convert local to world
        const forward = new THREE.Vector3(0,0,-1).applyQuaternion(yawObject.quaternion).setY(0).normalize();
        const right   = new THREE.Vector3(1,0,0).applyQuaternion(yawObject.quaternion).setY(0).normalize();

        yawObject.position.addScaledVector(forward, (dir.z) * speed * delta);
        yawObject.position.addScaledVector(right,   (dir.x) * speed * delta);

        // gravity + jump
        vel.y -= 9.8 * 2.0 * delta;
        yawObject.position.y += vel.y * delta;
        if(yawObject.position.y < 1.7){
          vel.y = 0;
          yawObject.position.y = 1.7;
          canJump = true;
        }

        resolveCollisions(prev);

        // mild head bob only when moving (doesn't affect aim too much)
        const moving = moveF || moveB || moveL || moveR;
        camera.position.y = 0;
        camera.position.y += moving ? Math.sin(time*9.0) * 0.04 : 0;
      }

      // enemies + interaction
      updateEnemies(delta, time);
      checkInteraction();

      // audio reacts to sanity/enemy proximity
      if(audio){
        const nearest = enemies.reduce((m,e)=>Math.min(m, e.mesh.position.distanceTo(yawObject.position)), 999);
        const fear = clamp((18 - nearest)/18, 0, 1);
        const sanity = 1 - (state.sanity/100);
        setAudioIntensity(0.18 + sanity*0.13 + fear*0.08);
        setAudioWhine((state.glitchMode ? 0.9 : 0.0) + fear*0.35);
      }

      // glitch FX
      applyGlitchFX(time);

      // slow sanity drift (atmosphere)
      const drift = (state.difficulty===2 ? 0.24 : state.difficulty===0 ? 0.14 : 0.18) * delta;
      state.sanity -= drift;
      syncBars();

      renderer.render(scene, camera);
    }

    // =============================
    // INPUTS
    // =============================
    document.addEventListener("keydown", (e) => {
      if(!state.isPlaying) return;
      switch(e.code){
        case "KeyW": moveF=true; break;
        case "KeyS": moveB=true; break;
        case "KeyA": moveL=true; break;
        case "KeyD": moveR=true; break;
        case "ShiftLeft": running=true; break;
        case "Space":
          if(canJump){ vel.y = 15; canJump=false; }
          break;
        case "KeyE":
          if(currentTarget) currentTarget.action();
          break;
        case "Escape":
          // unlock pointer (pause-ish)
          unlockPointer();
          break;
      }
    });
    document.addEventListener("keyup", (e) => {
      switch(e.code){
        case "KeyW": moveF=false; break;
        case "KeyS": moveB=false; break;
        case "KeyA": moveL=false; break;
        case "KeyD": moveR=false; break;
        case "ShiftLeft": running=false; break;
      }
    });

    function unlockPointer(){
      if(document.pointerLockElement) document.exitPointerLock();
      isLocked = false;
    }

    renderer.domElement.addEventListener("click", () => {
      if(state.isPlaying && ui.note.style.display !== "block"){
        requestLock();
      }
    });

    // Note close
    document.getElementById("note-close").addEventListener("click", () => {
      ui.note.style.display = "none";
      setSubtitle("SIGNAL RESUMED.", 800);
      requestLock();
    });

    // =============================
    // START
    // =============================
    document.getElementById("start-btn").addEventListener("click", async () => {
      const name = (document.getElementById("playerName").value || "UNKNOWN").trim().slice(0,20);
      state.playerName = name.length ? name.toUpperCase() : "UNKNOWN";

      sens = parseFloat(document.getElementById("sens").value);
      smoothing = parseFloat(document.getElementById("smooth").value);

      state.difficulty = parseInt(document.getElementById("difficulty").value, 10);
      state.audioOn = document.getElementById("audioMode").value === "1";
      state.ttsOn = document.getElementById("ttsMode").value === "1";

      document.getElementById("start-screen").style.display = "none";
      state.isPlaying = true;

      // audio must start after user gesture
      await ensureAudio();

      // spawn world
      state.hp = 100; state.sanity = 100; state.glitchMode = 0; state.keyFound = false;
      syncBars();

      // start position
      yawObject.position.set(5, 1.7, 5);
      targetYaw = yaw = 0;
      targetPitch = pitch = 0;

      generateCity();
      requestLock();

      animate();
    });

    // Resize
    addEventListener("resize", () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // First hint for browsers that block audio until gesture
    setSubtitle("CLICK ENTER SIMULATION. AUDIO STARTS ON USER INPUT.", 2600);
  </script>
</body>
</html>



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>GLITCH CITY: SECTOR 0 — MEMORY LEAK</title>

  <!-- Fix favicon.ico 404 -->
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64'%3E%3Crect width='64' height='64' fill='%23000'/%3E%3Cpath d='M10 40 L32 10 L54 40 Z' fill='%23f00'/%3E%3C/svg%3E">

  <style>
    body { margin:0; overflow:hidden; background:#000; font-family: "Courier New", monospace; }
    canvas { image-rendering: pixelated; }

    /* UI */
    #ui-layer { position:absolute; inset:0; pointer-events:none; z-index:10; }
    #crosshair{
      position:absolute; top:50%; left:50%;
      width:12px; height:12px; border:2px solid rgba(255,255,255,.85);
      border-radius:50%; transform:translate(-50%,-50%);
      transition: .12s ease;
      mix-blend-mode: screen;
    }
    .interact-active{
      border-color:#00ff66 !important;
      background: rgba(0,255,102,0.25);
      width:20px !important; height:20px !important;
      box-shadow: 0 0 18px rgba(0,255,102,.35);
    }

    #stats{
      position:absolute; bottom:18px; left:18px;
      color:#fff; font-size:18px; text-shadow:2px 2px 0 #000;
      width: 280px;
    }
    .stat-label{ font-size:14px; letter-spacing:.08em; color:#ddd; opacity:.92; }
    .stat-bar { width:240px; height:14px; background:#222; margin:6px 0 10px; border:1px solid rgba(255,255,255,.8); }
    .fill{ height:100%; transition: width .18s linear, filter .18s linear; }
    #hp-bar{ background:#c00; width:100%; }
    #san-bar{ background:#06c; width:100%; }

    #quest-log{
      margin-top:10px;
      font-size: 13px;
      color:#cfcfcf;
      opacity:.85;
      line-height: 1.25em;
      filter: contrast(1.2);
    }

    #minimap-container{
      position:absolute; top:18px; right:18px;
      width:156px; height:156px;
      background: rgba(0,0,0,0.55);
      border: 2px solid rgba(255,255,255,.8);
      border-radius: 50%;
      overflow:hidden;
      box-shadow: 0 0 18px rgba(0,0,0,.65);
    }
    #minimap{ width:100%; height:100%; opacity:.9; }

    #interaction-text{
      position:absolute; top:60%; left:50%;
      transform: translateX(-50%);
      color:#ff0; font-size:20px; font-weight:bold;
      text-shadow: 1px 1px 0 #000;
      display:none;
      filter: saturate(1.2);
    }

    /* Overlays */
    #note-overlay{
      display:none;
      position:absolute; top:50%; left:50%;
      transform:translate(-50%,-50%);
      width:min(520px, 90vw);
      background:#f3f3f3;
      color:#000;
      padding: 18px 18px 14px;
      font-family: "Times New Roman", serif;
      border: 10px solid #222;
      box-shadow: 0 0 60px #000;
      pointer-events:auto;
      text-align:left;
    }
    #note-overlay h2{ margin:0 0 8px; }
    #note-overlay p{ margin:0 0 12px; font-size: 18px; }

    #start-screen, #death-screen{
      position:absolute; inset:0;
      background: rgba(0,0,0,0.95);
      display:flex; flex-direction:column;
      justify-content:center; align-items:center;
      z-index:20; color:#fff; pointer-events:auto;
      text-align:center;
      padding: 24px;
    }

    .glitch-text{ animation: glitch .32s infinite; }
    @keyframes glitch{
      0%{ transform:translate(0); }
      20%{ transform:translate(-2px,2px); }
      40%{ transform:translate(-2px,-2px); }
      60%{ transform:translate(2px,2px); }
      80%{ transform:translate(2px,-2px); }
      100%{ transform:translate(0); }
    }

    button{
      padding: 12px 22px;
      font-size: 1.1em;
      background: #b00000;
      color: #fff;
      border: none;
      cursor: pointer;
      margin-top: 14px;
      font-family: "Courier New", monospace;
      letter-spacing: .05em;
      box-shadow: 0 0 18px rgba(176,0,0,.18);
    }
    button:hover{ background:#e00000; box-shadow: 0 0 22px rgba(224,0,0,.28); }

    input{
      pointer-events:auto;
      padding: 10px 12px;
      font-size: 1em;
      border: 1px solid rgba(255,255,255,.25);
      background: rgba(0,0,0,.4);
      color: #fff;
      outline: none;
      margin-top: 10px;
      width: min(360px, 85vw);
      font-family: "Courier New", monospace;
    }

    /* Sanity-driven overlays */
    #vignette{
      position:absolute; inset:0; z-index:9; pointer-events:none;
      background: radial-gradient(ellipse at center, rgba(0,0,0,0) 45%, rgba(0,0,0,.55) 76%, rgba(0,0,0,.92) 100%);
      opacity: .12;
      transition: opacity .2s linear;
      mix-blend-mode: multiply;
    }
    #scanlines{
      position:absolute; inset:0; z-index:9; pointer-events:none;
      background: repeating-linear-gradient(
        to bottom,
        rgba(255,255,255,0.03) 0px,
        rgba(255,255,255,0.03) 1px,
        rgba(0,0,0,0.00) 2px,
        rgba(0,0,0,0.00) 4px
      );
      opacity: .08;
      transition: opacity .2s linear;
      mix-blend-mode: overlay;
    }
    #noise{
      position:absolute; inset:0; z-index:9; pointer-events:none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='120' height='120' filter='url(%23n)' opacity='.35'/%3E%3C/svg%3E");
      opacity: .00;
      transition: opacity .15s linear;
      mix-blend-mode: soft-light;
    }
  </style>
</head>
<body>

  <div id="ui-layer">
    <div id="crosshair"></div>
    <div id="minimap-container"><canvas id="minimap" width="300" height="300"></canvas></div>

    <div id="stats">
      <div class="stat-label">DATA INTEGRITY (HP)</div>
      <div class="stat-bar"><div id="hp-bar" class="fill"></div></div>
      <div class="stat-label">LOGIC STABILITY (SANITY)</div>
      <div class="stat-bar"><div id="san-bar" class="fill"></div></div>
      <div id="quest-log">OBJECTIVE: FIND THE SERVER ROOM KEY.<br/>THE CITY REMEMBERS YOUR NAME.</div>
    </div>

    <div id="interaction-text">PRESS [E] TO INTERACT</div>
  </div>

  <div id="vignette"></div>
  <div id="scanlines"></div>
  <div id="noise"></div>

  <div id="note-overlay">
    <h2 id="note-title">NOTE</h2>
    <p id="note-content">...</p>
    <button id="note-close">PUT AWAY</button>
  </div>

  <div id="start-screen">
    <h1 class="glitch-text" style="font-size:3.2em; color:#ff2020; margin:0;">GLITCH CITY</h1>
    <p style="max-width:720px; opacity:.9;">
      SECTOR 7 IS CORRUPTED. IT RAINS DATA. YOU ARE A MEMORY THAT WON'T DELETE.
    </p>
    <p style="opacity:.85;">WASD Move • SHIFT Run • SPACE Jump • E Interact • LMB Attack • T Speak</p>

    <input id="name-input" maxlength="18" placeholder="CHOOSE YOUR NAME (it will appear in the city)"/>
    <button id="start-btn">ENTER SIMULATION</button>

    <p style="opacity:.55; margin-top:16px; font-size: 12px;">
      Tip: sanity is fragile — the walls are not.
    </p>
  </div>

  <div id="death-screen" style="display:none;">
    <h1 style="color:#ff3030; margin:0 0 10px;">CONNECTION LOST</h1>
    <p id="death-reason" style="opacity:.9;"></p>
    <button onclick="location.reload()">RESPAWN</button>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from "three";
    import { PointerLockControls } from "three/addons/controls/PointerLockControls.js";

    // ========= CONFIG =========
    const config = {
      mapSize: 44,
      scale: 4,
      enemyCount: 8,
      itemCount: 16,
      wallScareCount: 10,
      nameGraffitiCount: 10,
      pocketRooms: 3,
      maxEnemies: 14
    };

    const assets = {
      // your images (place in /assets)
      back: "assets/back.png",
      back2: "assets/back2.png",
      object1: "assets/object1.png",
      fiend: "assets/fiend.png",
      npc: "assets/npc.png",
      npc3: "assets/npc3.png",
      image1: "assets/image.png",
      image2: "assets/image2.png"
    };

    // ========= STATE =========
    const state = {
      hp: 100,
      sanity: 100,
      isPlaying: false,
      glitch: 0,           // 0..1
      playerName: "NO-ONE",
      hasKey: false,
      weapon: "none",      // none | pipe | shard
      ammo: 0,
      lastShot: 0,
      ttsCooldown: 0,
      timeAlive: 0
    };

    // ========= UI REFS =========
    const hpBar = document.getElementById("hp-bar");
    const sanBar = document.getElementById("san-bar");
    const vignette = document.getElementById("vignette");
    const scanlines = document.getElementById("scanlines");
    const noiseOverlay = document.getElementById("noise");

    function clamp01(v){ return Math.max(0, Math.min(1, v)); }
    function lerp(a,b,t){ return a + (b-a)*t; }

    // ========= THREE SETUP =========
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x1a1a22);

    const camera = new THREE.PerspectiveCamera(78, innerWidth/innerHeight, 0.08, 160);
    const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:"high-performance" });
    renderer.setSize(innerWidth, innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // PS2-ish touch: slightly lower internal res on purpose (optional)
    // renderer.setPixelRatio(Math.min(devicePixelRatio, 1.15));

    // Fog (will thicken as sanity drops)
    scene.fog = new THREE.FogExp2(0x14141a, 0.018);

    // Lights: start brighter
    const hemi = new THREE.HemisphereLight(0xcfd6ff, 0x1a1020, 0.9);
    scene.add(hemi);

    const keyLight = new THREE.DirectionalLight(0xdde6ff, 0.9);
    keyLight.position.set(60, 80, 40);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.set(1024, 1024);
    scene.add(keyLight);

    const flashlight = new THREE.SpotLight(0xfff6e6, 2.2, 52, Math.PI/7, 0.55, 1);
    flashlight.position.set(0,0,0);
    flashlight.target.position.set(0,0,-1);
    camera.add(flashlight);
    camera.add(flashlight.target);
    scene.add(camera);

    const controls = new PointerLockControls(camera, document.body);

    // ========= TEXTURES (procedural + loaded) =========
    const texLoader = new THREE.TextureLoader();
    const textures = {};
    const loaded = {};

    function makeCanvasTexture(drawFn, size=512){
      const c = document.createElement("canvas");
      c.width = c.height = size;
      const ctx = c.getContext("2d");
      drawFn(ctx, size);
      const t = new THREE.CanvasTexture(c);
      t.wrapS = t.wrapT = THREE.RepeatWrapping;
      t.anisotropy = 2;
      return t;
    }

    textures.concrete = makeCanvasTexture((ctx,S)=>{
      ctx.fillStyle="#3b3b3f"; ctx.fillRect(0,0,S,S);
      for(let i=0;i<14000;i++){
        ctx.globalAlpha=0.08;
        ctx.fillStyle = Math.random()<0.5 ? "#0b0b0f" : "#ffffff";
        ctx.fillRect(Math.random()*S, Math.random()*S, 2, 2);
      }
      ctx.globalAlpha=1;
    });
    textures.brick = makeCanvasTexture((ctx,S)=>{
      ctx.fillStyle="#3f1a1a"; ctx.fillRect(0,0,S,S);
      ctx.strokeStyle="#1e0b0b"; ctx.lineWidth=4;
      for(let y=0;y<S;y+=64){
        for(let x=0;x<S;x+=128){
          const off = (y/64)%2===0 ? 0 : 64;
          ctx.strokeRect(x+off, y, 128, 64);
          if(Math.random()>0.35){
            ctx.fillStyle="rgba(0,0,0,0.22)";
            ctx.fillRect(x+off+8, y+10, 110, 38);
          }
        }
      }
    });
    textures.wood = makeCanvasTexture((ctx,S)=>{
      ctx.fillStyle="#4a2a1a"; ctx.fillRect(0,0,S,S);
      ctx.strokeStyle="rgba(0,0,0,0.25)";
      for(let i=0;i<S;i+=4){
        ctx.beginPath();
        ctx.moveTo(0, i + (Math.random()*10-5));
        ctx.lineTo(S, i + (Math.random()*10-5));
        ctx.stroke();
      }
    });
    textures.grass = makeCanvasTexture((ctx,S)=>{
      ctx.fillStyle="#142114"; ctx.fillRect(0,0,S,S);
      for(let i=0;i<22000;i++){
        ctx.globalAlpha=0.06;
        ctx.fillStyle = Math.random()<0.5 ? "#2c612c" : "#0a0f0a";
        ctx.fillRect(Math.random()*S, Math.random()*S, 2, 2);
      }
      ctx.globalAlpha=1;
    });
    textures.static = makeCanvasTexture((ctx,S)=>{
      ctx.fillStyle="#000"; ctx.fillRect(0,0,S,S);
      for(let i=0;i<52000;i++){
        ctx.globalAlpha=1;
        const v = (Math.random()*255)|0;
        ctx.fillStyle=`rgb(${v},${v},${v})`;
        ctx.fillRect(Math.random()*S, Math.random()*S, 2, 2);
      }
    });

    function tryLoadTexture(key, url){
      return new Promise((resolve)=>{
        texLoader.load(url, (t)=>{
          t.wrapS = t.wrapT = THREE.RepeatWrapping;
          t.anisotropy = 2;
          loaded[key] = t;
          resolve(true);
        }, undefined, ()=>resolve(false));
      });
    }

    await Promise.all([
      tryLoadTexture("back", assets.back),
      tryLoadTexture("back2", assets.back2),
      tryLoadTexture("object1", assets.object1),
      tryLoadTexture("fiend", assets.fiend),
      tryLoadTexture("npc", assets.npc),
      tryLoadTexture("npc3", assets.npc3),
      tryLoadTexture("image1", assets.image1),
      tryLoadTexture("image2", assets.image2),
    ]);

    // ========= AUDIO (AudioWorklet breath/noise + optional TTS) =========
    let audioCtx = null;
    let master = null;
    let breathNode = null;
    let droneOsc = null;
    let droneGain = null;

    async function ensureAudio(){
      if(audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      master = audioCtx.createGain();
      master.gain.value = 0.55;
      master.connect(audioCtx.destination);

      // Worklet: breathy noise + low thumps
      const workletCode = `
        class BreathNoise extends AudioWorkletProcessor {
          constructor(){
            super();
            this.t = 0;
            this.phase = 0;
            this.seed = 1234567;
            this.breath = 0;
          }
          rnd(){
            // xorshift-ish
            this.seed ^= this.seed << 13;
            this.seed ^= this.seed >> 17;
            this.seed ^= this.seed << 5;
            return (this.seed >>> 0) / 4294967295;
          }
          process(inputs, outputs, params){
            const out = outputs[0];
            const ch0 = out[0];
            const sr = sampleRate;

            for(let i=0;i<ch0.length;i++){
              const time = this.t / sr;

              // Breath envelope (slow, uneasy)
              const breathRate = 0.18 + 0.03*Math.sin(time*0.37);
              this.breath = 0.55 + 0.45*Math.sin(2*Math.PI*breathRate*time + Math.sin(time*0.11));

              // White noise
              const n = (this.rnd()*2-1);

              // Cheap “air” filter by mixing noise with envelope
              let air = n * (0.08 + 0.11*this.breath);

              // Low thump pulse
              const th = Math.sin(2*Math.PI*1.1*time) * Math.sin(2*Math.PI*0.25*time);
              let thump = th * 0.02;

              // Subtle digital flutter
              const flutter = (Math.sin(2*Math.PI*12.0*time) > 0.96) ? 0.03 : 0.0;

              ch0[i] = air + thump + flutter;
              this.t++;
            }

            // mono -> stereo if needed
            if(out.length > 1){
              const ch1 = out[1];
              for(let i=0;i<ch0.length;i++) ch1[i] = ch0[i]*0.98;
            }
            return true;
          }
        }
        registerProcessor('breath-noise', BreathNoise);
      `;
      const blob = new Blob([workletCode], { type:"application/javascript" });
      const url = URL.createObjectURL(blob);
      await audioCtx.audioWorklet.addModule(url);

      breathNode = new AudioWorkletNode(audioCtx, "breath-noise");
      const breathGain = audioCtx.createGain();
      breathGain.gain.value = 0.55;

      // ominous drone (two detuned sines)
      droneOsc = audioCtx.createOscillator();
      droneOsc.type = "sine";
      droneOsc.frequency.value = 43;

      const droneOsc2 = audioCtx.createOscillator();
      droneOsc2.type = "sine";
      droneOsc2.frequency.value = 43.8;

      droneGain = audioCtx.createGain();
      droneGain.gain.value = 0.22;

      const filter = audioCtx.createBiquadFilter();
      filter.type = "lowpass";
      filter.frequency.value = 520;

      breathNode.connect(breathGain).connect(filter);
      droneOsc.connect(droneGain).connect(filter);
      droneOsc2.connect(droneGain).connect(filter);
      filter.connect(master);

      droneOsc.start();
      droneOsc2.start();
    }

    // TTS (Web Speech API) — press T or triggers will call speak()
    function speak(text){
      if(!("speechSynthesis" in window)) return;
      if(state.ttsCooldown > 0) return;
      state.ttsCooldown = 4.0;

      const u = new SpeechSynthesisUtterance(text);
      u.rate = 0.92;
      u.pitch = 0.72;
      u.volume = 0.9;
      speechSynthesis.cancel();
      speechSynthesis.speak(u);
    }

    // ========= WORLD =========
    const colliders = [];
    const interactables = [];
    const enemies = [];
    const bullets = [];
    const decals = []; // animated name graffiti

    // Map grid (for minimap + spawn logic)
    const map = [];
    const raycaster = new THREE.Raycaster();
    let currentTarget = null;

    // Ground
    const groundGeo = new THREE.PlaneGeometry(config.mapSize*config.scale, config.mapSize*config.scale);
    const groundMat = new THREE.MeshStandardMaterial({ map: textures.grass, roughness: 1.0 });
    groundMat.map.repeat.set(8,8);
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.position.set(config.mapSize*config.scale/2, 0, config.mapSize*config.scale/2);
    ground.receiveShadow = true;
    scene.add(ground);

    // Sky dome (your backgrounds)
    const skyGeo = new THREE.SphereGeometry(120, 18, 14);
    const skyMat = new THREE.MeshBasicMaterial({
      map: loaded.back2 || loaded.back || null,
      color: loaded.back2 || loaded.back ? 0xffffff : 0x0b0b10,
      side: THREE.BackSide
    });
    if(skyMat.map){ skyMat.map.repeat.set(1,1); }
    const sky = new THREE.Mesh(skyGeo, skyMat);
    sky.position.set(config.mapSize*config.scale/2, 24, config.mapSize*config.scale/2);
    scene.add(sky);

    // City bounds walls
    function addBounds(){
      const W = config.mapSize*config.scale;
      const wallMat = new THREE.MeshStandardMaterial({ color: 0x07070a, roughness: 1 });
      const w1 = new THREE.Mesh(new THREE.BoxGeometry(W, 16, 1), wallMat); w1.position.set(W/2, 8, -1); scene.add(w1); colliders.push(w1);
      const w2 = new THREE.Mesh(new THREE.BoxGeometry(W, 16, 1), wallMat); w2.position.set(W/2, 8, W+1); scene.add(w2); colliders.push(w2);
      const w3 = new THREE.Mesh(new THREE.BoxGeometry(1, 16, W), wallMat); w3.position.set(-1, 8, W/2); scene.add(w3); colliders.push(w3);
      const w4 = new THREE.Mesh(new THREE.BoxGeometry(1, 16, W), wallMat); w4.position.set(W+1, 8, W/2); scene.add(w4); colliders.push(w4);
    }

    // ========= PREFABS =========
    function spawnBuilding(x,z){
      const h = 5 + Math.random()*12;
      const geo = new THREE.BoxGeometry(3.4, h, 3.4);
      const mat = new THREE.MeshStandardMaterial({ map: textures.brick, roughness: 1.0 });
      mat.map.repeat.set(1, 1);
      const m = new THREE.Mesh(geo, mat);
      m.position.set(x, h/2, z);
      m.castShadow = true;
      m.receiveShadow = true;
      scene.add(m);
      colliders.push(m);
    }

    function spawnTree(x,z,dead=false){
      const trunkG = new THREE.CylinderGeometry(0.22, 0.32, dead ? 3.6 : 3.0, 7);
      const trunkM = new THREE.MeshStandardMaterial({ map: textures.wood, roughness: 1.0, color: dead ? 0x2a1a12 : 0x3a2a1a });
      const trunk = new THREE.Mesh(trunkG, trunkM);
      trunk.position.set(x, 1.6, z);
      trunk.castShadow = true;
      trunk.receiveShadow = true;

      if(!dead){
        const leavesG = new THREE.ConeGeometry(1.9, 4.2, 8);
        const leavesM = new THREE.MeshStandardMaterial({ color: 0x173717, roughness: 1 });
        const leaves = new THREE.Mesh(leavesG, leavesM);
        leaves.position.y = 2.7;
        leaves.castShadow = true;
        trunk.add(leaves);
      } else {
        // dead branches
        for(let i=0;i<4;i++){
          const b = new THREE.Mesh(
            new THREE.CylinderGeometry(0.04, 0.08, 1.2, 6),
            new THREE.MeshStandardMaterial({ color: 0x1a0f0a, roughness: 1 })
          );
          b.position.y = 2.6 + Math.random()*0.5;
          b.rotation.z = (Math.random()*0.8 + 0.2) * (Math.random()<0.5?-1:1);
          b.rotation.x = (Math.random()*0.8 - 0.4);
          trunk.add(b);
        }
      }

      scene.add(trunk);
      colliders.push(trunk);
    }

    function spawnBed(x,z){
      const base = new THREE.Mesh(
        new THREE.BoxGeometry(2.2, 0.35, 1.0),
        new THREE.MeshStandardMaterial({ color: 0x2a2a2f, roughness: 1 })
      );
      base.position.set(x, 0.25, z);
      base.castShadow = true; base.receiveShadow = true;

      const mattress = new THREE.Mesh(
        new THREE.BoxGeometry(2.1, 0.28, 0.92),
        new THREE.MeshStandardMaterial({ color: 0x6a6a72, roughness: 1 })
      );
      mattress.position.set(0, 0.28, 0);
      base.add(mattress);

      // “stain”
      const stain = new THREE.Mesh(
        new THREE.PlaneGeometry(0.8,0.6),
        new THREE.MeshBasicMaterial({ color: 0x220006, transparent:true, opacity:0.35 })
      );
      stain.rotation.x = -Math.PI/2;
      stain.position.set(0.3, 0.16, 0);
      mattress.add(stain);

      scene.add(base);
      colliders.push(base);

      // chance: item under bed
      if(Math.random() < 0.35){
        spawnPickup(x + (Math.random()*0.6-0.3), z + (Math.random()*0.4-0.2), Math.random()<0.6 ? "pipe" : "badpill");
      }
    }

    function spawnNails(x,z){
      const group = new THREE.Group();
      const count = 8 + (Math.random()*10|0);
      for(let i=0;i<count;i++){
        const nail = new THREE.Mesh(
          new THREE.CylinderGeometry(0.03, 0.04, 0.55, 6),
          new THREE.MeshStandardMaterial({ color: 0x3a2f2f, roughness: 1, metalness: 0.1 })
        );
        nail.position.set((Math.random()-0.5)*1.6, 0.28, (Math.random()-0.5)*1.2);
        nail.rotation.x = (Math.random()*0.8 - 0.4);
        nail.rotation.z = (Math.random()*0.8 - 0.4);
        nail.castShadow = true;
        group.add(nail);
      }
      group.position.set(x, 0, z);
      scene.add(group);
      colliders.push(group);
    }

    function spawnBrokenTV(x,z){
      const tv = new THREE.Mesh(
        new THREE.BoxGeometry(1.05, 0.82, 0.82),
        new THREE.MeshStandardMaterial({ color: 0x2a2a2d, roughness: 1 })
      );
      tv.position.set(x, 0.41, z);
      tv.castShadow = true;

      const screen = new THREE.Mesh(
        new THREE.PlaneGeometry(0.88, 0.66),
        new THREE.MeshBasicMaterial({ map: textures.static })
      );
      screen.position.z = 0.42;
      tv.add(screen);

      const light = new THREE.PointLight(0xaadfff, 1.0, 3.0);
      light.position.set(0, 0.2, 0.9);
      tv.add(light);

      tv.userData = { type:"tv", light, screen };

      scene.add(tv);
      colliders.push(tv);

      // Interactable: TV whispers your name (TTS)
      interactables.push({
        mesh: tv,
        text: "LISTEN",
        action: () => {
          const lines = [
            `${state.playerName}… the city is learning your shape.`,
            `Don't trust the map, ${state.playerName}.`,
            `If you see yourself on the wall… run.`,
            `Your name tastes like iron.`
          ];
          speak(lines[(Math.random()*lines.length)|0]);
          // a little sanity tick down
          addSanity(-3 - Math.random()*4);
        }
      });
    }

    function spawnNote(x,z,title,content,creepy=0.35){
      const mesh = new THREE.Mesh(
        new THREE.PlaneGeometry(0.52, 0.66),
        new THREE.MeshBasicMaterial({ color: 0xfafafa, side: THREE.DoubleSide })
      );
      mesh.rotation.x = -Math.PI/2;
      mesh.position.set(x, 0.05, z);
      scene.add(mesh);

      interactables.push({
        mesh,
        text: "READ NOTE",
        action: () => {
          openNote(title, content);
          // sanity impact scales with creepiness
          addSanity(-(6*creepy + 2));
          // sometimes it “talks”
          if(Math.random() < 0.35){
            speak(content.length > 120 ? content.slice(0, 120) : content);
          }
        }
      });
    }

    function spawnWallScare(x,z,texKey){
      // A wall panel with scary image; staring at it drains sanity (on interact)
      const tex = loaded[texKey];
      const mat = new THREE.MeshBasicMaterial({
        map: tex || textures.static,
        color: tex ? 0xffffff : 0xbdbdbd
      });
      if(tex){
        tex.minFilter = THREE.LinearFilter;
      }
      const plane = new THREE.Mesh(new THREE.PlaneGeometry(2.2, 2.2), mat);
      plane.position.set(x, 1.7, z);
      plane.rotation.y = Math.random() * Math.PI*2;
      scene.add(plane);
      colliders.push(plane);

      interactables.push({
        mesh: plane,
        text: "LOOK",
        action: () => {
          addSanity(-10 - Math.random()*10);
          // hard glitch burst
          state.glitch = Math.min(1, state.glitch + 0.4);
          // whisper
          if(Math.random() < 0.75){
            speak(`${state.playerName}… it is behind the texture.`);
          }
        }
      });
    }

    function makeDrippingNameTexture(name){
      const S = 512;
      const c = document.createElement("canvas");
      c.width = c.height = S;
      const ctx = c.getContext("2d");

      const drops = Array.from({length: 70}, ()=>({
        x: Math.random()*S,
        y: Math.random()*S*0.3,
        v: 20 + Math.random()*70,
        w: 2 + Math.random()*5,
        a: 0.35 + Math.random()*0.55
      }));

      function draw(t){
        ctx.clearRect(0,0,S,S);

        // grime base
        ctx.fillStyle = "rgba(255,255,255,0.03)";
        ctx.fillRect(0,0,S,S);

        // text
        ctx.save();
        ctx.translate(S/2, S/2);
        ctx.rotate((Math.sin(t*0.4)*0.03));
        ctx.font = "bold 80px Courier New";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "rgba(120,0,20,0.95)";
        ctx.shadowColor = "rgba(0,0,0,0.65)";
        ctx.shadowBlur = 18;
        ctx.fillText(name, 0, -20);
        ctx.restore();

        // drips (cranberry)
        for(const d of drops){
          const yy = d.y + (t * d.v) % (S*1.2);
          ctx.globalAlpha = d.a;
          ctx.fillStyle = "rgba(150,0,25,1)";
          ctx.fillRect(d.x, yy, d.w, 30 + Math.sin((d.x+yy)*0.01)*12);
          ctx.beginPath();
          ctx.arc(d.x + d.w*0.5, yy+36, 6 + Math.sin(t*2 + d.x*0.01)*3, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;

        // subtle noise
        ctx.globalAlpha = 0.08;
        for(let i=0;i<1200;i++){
          ctx.fillStyle = Math.random()<0.5 ? "#000" : "#fff";
          ctx.fillRect(Math.random()*S, Math.random()*S, 1, 1);
        }
        ctx.globalAlpha = 1;
      }

      const tex = new THREE.CanvasTexture(c);
      tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
      tex.anisotropy = 2;

      return { tex, tick: (t)=>{ draw(t); tex.needsUpdate = true; } };
    }

    function spawnNameGraffiti(x,z){
      const { tex, tick } = makeDrippingNameTexture(state.playerName);
      const mat = new THREE.MeshBasicMaterial({ map: tex, transparent:true, opacity: 0.95 });
      const p = new THREE.Mesh(new THREE.PlaneGeometry(3.6, 2.2), mat);
      p.position.set(x, 1.6, z);
      p.rotation.y = Math.random()*Math.PI*2;
      scene.add(p);
      decals.push({ mesh:p, tick, wobble: Math.random()*10 });

      // sometimes: interacting makes you lose sanity (because recognition)
      interactables.push({
        mesh: p,
        text: "TOUCH YOUR NAME",
        action: () => {
          addSanity(-(6 + Math.random()*10));
          state.glitch = Math.min(1, state.glitch + 0.25);
          speak(`${state.playerName}. ${state.playerName}. ${state.playerName}.`);
        }
      });
    }

    function spawnDoor(x,z,label,onOpen){
      const door = new THREE.Mesh(
        new THREE.BoxGeometry(2.0, 4.0, 0.25),
        new THREE.MeshStandardMaterial({ map: textures.wood, color: 0x4a2525, roughness: 1 })
      );
      door.position.set(x, 2, z);
      door.castShadow = true;
      scene.add(door);
      colliders.push(door);

      let opened = false;
      interactables.push({
        mesh: door,
        text: opened ? "…" : `OPEN ${label}`,
        action: () => {
          if(opened) return;
          opened = true;

          // creaky open
          const targetRot = door.rotation.y + (Math.random()<0.5 ? 1 : -1) * (Math.PI/2);
          const start = door.rotation.y;
          const t0 = performance.now();

          const idx = colliders.indexOf(door);
          if(idx>-1) colliders.splice(idx,1);

          (function anim(){
            const t = (performance.now()-t0)/260;
            door.rotation.y = lerp(start, targetRot, clamp01(t));
            if(t<1) requestAnimationFrame(anim);
            else {
              if(onOpen) onOpen();
            }
          })();

          speak(`Door accepted. ${state.playerName}.`);
        }
      });
    }

    function spawnPickup(x,z,type){
      const color = (type==="pipe") ? 0xaaaaaa :
                    (type==="shard") ? 0x66ccff :
                    (type==="key") ? 0xffdd55 :
                    (type==="badpill") ? 0x77ff55 :
                    0xffaa00;

      const m = new THREE.Mesh(
        new THREE.DodecahedronGeometry(0.28),
        new THREE.MeshStandardMaterial({ color, emissive: 0x111111, roughness: 0.6 })
      );
      m.position.set(x, 0.55, z);
      m.castShadow = true;
      scene.add(m);

      const text =
        type==="pipe" ? "TAKE RUSTY PIPE" :
        type==="shard" ? "TAKE DATA SHARD" :
        type==="key" ? "TAKE SERVER KEY" :
        type==="badpill" ? "TAKE PILLS" :
        "TAKE";

      interactables.push({
        mesh: m,
        text,
        action: () => {
          scene.remove(m);
          if(type==="pipe"){
            state.weapon = "pipe";
            speak(`A pipe. Better than prayers, ${state.playerName}.`);
          } else if(type==="shard"){
            state.weapon = "shard";
            state.ammo += 8 + (Math.random()*6|0);
            speak(`A shard that edits flesh.`);
          } else if(type==="key"){
            state.hasKey = true;
            document.getElementById("quest-log").innerHTML = "OBJECTIVE: OPEN THE SERVER ROOM DOOR.<br/>THE CITY IS QUIETER NOW.";
            speak(`Key acquired. The server room is awake.`);
          } else if(type==="badpill"){
            // bad item: big glitch, sanity hit
            addSanity(-(12 + Math.random()*12));
            state.hp = Math.min(100, state.hp + 8);
            state.glitch = Math.min(1, state.glitch + 0.6);
            speak(`Sweet relief. Bitter consequences.`);
          }
        }
      });
    }

    function spawnEnemy(){
      // Billboard PNG monster
      const choices = [loaded.fiend, loaded.npc, loaded.npc3, loaded.object1].filter(Boolean);
      const t = choices.length ? choices[(Math.random()*choices.length)|0] : null;

      const mat = new THREE.SpriteMaterial({
        map: t || textures.static,
        color: 0xffffff,
        transparent: true,
        opacity: 0.98
      });

      const spr = new THREE.Sprite(mat);
      spr.scale.set(2.4, 3.2, 1);
      spr.position.set(Math.random()*(config.mapSize*config.scale-10)+5, 1.8, Math.random()*(config.mapSize*config.scale-10)+5);
      scene.add(spr);

      enemies.push({
        mesh: spr,
        hp: 28 + (Math.random()*22|0),
        speed: 1.7 + Math.random()*1.8,
        aggro: 0.0,
        phase: Math.random()*10
      });
    }

    function damageEnemy(e, dmg){
      e.hp -= dmg;
      e.aggro = 1.0;
      // flash
      e.mesh.material.opacity = 0.65;
      setTimeout(()=>{ if(e.mesh?.material) e.mesh.material.opacity = 0.98; }, 80);

      if(e.hp <= 0){
        // drop chance
        if(Math.random() < 0.45){
          spawnPickup(e.mesh.position.x, e.mesh.position.z, Math.random()<0.65 ? "shard" : "badpill");
        }
        scene.remove(e.mesh);
        const idx = enemies.indexOf(e);
        if(idx>-1) enemies.splice(idx,1);
      }
    }

    // ========= NOTE OVERLAY =========
    function openNote(title, content){
      document.getElementById("note-title").innerText = title;
      document.getElementById("note-content").innerText = content;
      document.getElementById("note-overlay").style.display = "block";
      document.exitPointerLock?.();
    }
    document.getElementById("note-close").addEventListener("click", ()=>{
      document.getElementById("note-overlay").style.display = "none";
      controls.lock();
    });

    // ========= SANITY / HP =========
    function updateBars(){
      hpBar.style.width = `${Math.max(0, state.hp)}%`;
      sanBar.style.width = `${Math.max(0, state.sanity)}%`;
      // more sanity loss => harsher look
      const sat = lerp(1.2, 0.6, 1 - state.sanity/100);
      sanBar.style.filter = `saturate(${sat})`;
    }

    function addSanity(delta){
      state.sanity = Math.max(0, Math.min(100, state.sanity + delta));
      updateBars();
    }
    function addHP(delta){
      state.hp = Math.max(0, Math.min(100, state.hp + delta));
      updateBars();
    }

    // ========= MINIMAP =========
    const mapCanvas = document.getElementById("minimap");
    const mapCtx = mapCanvas.getContext("2d");

    function drawMinimap(){
      const W = mapCanvas.width, H = mapCanvas.height;
      mapCtx.clearRect(0,0,W,H);
      mapCtx.fillStyle = "#000";
      mapCtx.fillRect(0,0,W,H);

      const cx = W/2, cy = H/2;
      const px = camera.position.x;
      const pz = camera.position.z;

      // sanity -> glitches & lies
      const s = state.sanity/100;
      const lie = (1-s) * (Math.random() < (0.08 + (1-s)*0.22) ? 1 : 0);
      const zoom = 2.0 + (1-s)*1.4;

      // rotate minimap slightly at low sanity
      const rot = (1-s) * (Math.sin(performance.now()*0.001)*0.6);

      mapCtx.save();
      mapCtx.translate(cx, cy);
      mapCtx.rotate(rot);

      // draw nearby colliders as blocks
      mapCtx.fillStyle = "#444";
      for(const obj of colliders){
        const rx = (obj.position.x - px) * zoom;
        const ry = (obj.position.z - pz) * zoom;
        if(Math.abs(rx) < cx && Math.abs(ry) < cy){
          mapCtx.fillRect(rx-3, ry-3, 6, 6);
        }
      }

      // enemies
      mapCtx.fillStyle = "#ff3030";
      for(const e of enemies){
        let ex = (e.mesh.position.x - px) * zoom;
        let ey = (e.mesh.position.z - pz) * zoom;
        if(lie){
          ex += (Math.random()*120-60);
          ey += (Math.random()*120-60);
        }
        if(Math.abs(ex) < cx && Math.abs(ey) < cy){
          mapCtx.fillRect(ex-2, ey-2, 4, 4);
        }
      }

      // false pings at low sanity
      if((1-s) > 0.35){
        const n = (1-s)*6;
        for(let i=0;i<n;i++){
          mapCtx.fillStyle = Math.random() < 0.5 ? "#ff0" : "#0ff";
          mapCtx.fillRect((Math.random()*W - cx) * 0.65, (Math.random()*H - cy) * 0.65, 2, 2);
        }
      }

      // player dot
      mapCtx.fillStyle = "#00ff66";
      mapCtx.beginPath();
      mapCtx.arc(0, 0, 5, 0, Math.PI*2);
      mapCtx.fill();

      mapCtx.restore();

      // vignette circle mask effect (fake circular minimap)
      mapCtx.globalCompositeOperation = "source-in";
      mapCtx.beginPath();
      mapCtx.arc(cx, cy, cx-2, 0, Math.PI*2);
      mapCtx.fill();
      mapCtx.globalCompositeOperation = "source-over";

      // scan noise if low sanity
      if((1-s) > 0.45){
        mapCtx.globalAlpha = 0.18;
        mapCtx.fillStyle = "#fff";
        for(let i=0;i<600;i++){
          mapCtx.fillRect(Math.random()*W, Math.random()*H, 1, 1);
        }
        mapCtx.globalAlpha = 1;
      }
    }

    // ========= INTERACTION =========
    function checkInteraction(){
      raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
      const list = interactables.map(i=>i.mesh);
      const hits = raycaster.intersectObjects(list, true);
      if(hits.length && hits[0].distance < 3.8){
        const hitObj = hits[0].object;
        const data = interactables.find(i => i.mesh === hitObj || i.mesh === hitObj.parent);
        if(data){
          document.getElementById("crosshair").classList.add("interact-active");
          const it = document.getElementById("interaction-text");
          it.style.display = "block";
          it.innerText = "[E] " + data.text;
          currentTarget = data;
          return;
        }
      }
      document.getElementById("crosshair").classList.remove("interact-active");
      document.getElementById("interaction-text").style.display = "none";
      currentTarget = null;
    }

    // ========= SHOOT / MELEE =========
    function tryAttack(){
      const now = performance.now()/1000;
      if(state.weapon === "none"){
        // weak shove
        meleeHit(10, 1.8);
        return;
      }
      if(state.weapon === "pipe"){
        meleeHit(22, 2.4);
        return;
      }
      if(state.weapon === "shard"){
        if(state.ammo <= 0){
          speak("Empty.");
          return;
        }
        if(now - state.lastShot < 0.22) return;
        state.lastShot = now;
        state.ammo--;

        // raycast forward damage
        raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
        const hits = raycaster.intersectObjects(enemies.map(e=>e.mesh));
        if(hits.length && hits[0].distance < 22){
          const target = enemies.find(e => e.mesh === hits[0].object);
          if(target){
            damageEnemy(target, 18 + (Math.random()*8|0));
            // shard makes reality worse
            state.glitch = Math.min(1, state.glitch + 0.08);
          }
        } else {
          // miss: tiny glitch anyway
          state.glitch = Math.min(1, state.glitch + 0.03);
        }
      }
    }

    function meleeHit(dmg, range){
      raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
      const hits = raycaster.intersectObjects(enemies.map(e=>e.mesh));
      if(hits.length && hits[0].distance < range){
        const target = enemies.find(e => e.mesh === hits[0].object);
        if(target){
          damageEnemy(target, dmg + (Math.random()*6|0));
          // knockback
          const dir = new THREE.Vector3();
          camera.getWorldDirection(dir);
          target.mesh.position.add(dir.multiplyScalar(0.65));
        }
      }
    }

    // ========= RAIN (data) =========
    const rainCount = 7000;
    const rainGeo = new THREE.BufferGeometry();
    const rainPos = new Float32Array(rainCount*3);
    const W = config.mapSize*config.scale;
    for(let i=0;i<rainCount*3;i+=3){
      rainPos[i] = Math.random()*W;
      rainPos[i+1] = Math.random()*80;
      rainPos[i+2] = Math.random()*W;
    }
    rainGeo.setAttribute("position", new THREE.BufferAttribute(rainPos, 3));
    const rainMat = new THREE.PointsMaterial({ color:0xbfc7ff, size:0.07, transparent:true, opacity:0.35 });
    const rain = new THREE.Points(rainGeo, rainMat);
    scene.add(rain);

    function updateWeather(dt){
      const p = rain.geometry.attributes.position.array;
      const sp = 18 + (1 - state.sanity/100)*26;
      for(let i=1;i<rainCount*3;i+=3){
        p[i] -= sp*dt;
        if(p[i] < 0) p[i] = 80;
      }
      rain.geometry.attributes.position.needsUpdate = true;

      // lightning more frequent at low sanity
      const s = state.sanity/100;
      if(Math.random() > (0.997 - (1-s)*0.01)){
        hemi.intensity = 1.8;
        keyLight.intensity = 1.4;
        setTimeout(()=>{
          hemi.intensity = lerp(0.35, 0.9, s);
          keyLight.intensity = lerp(0.28, 0.9, s);
        }, 80);
      }
    }

    // ========= COLLISION (simple) =========
    const tmpBox = new THREE.Box3();
    const playerBox = new THREE.Box3();
    const playerSize = new THREE.Vector3(0.6, 1.7, 0.6);

    function resolveCollisions(prevPos){
      playerBox.setFromCenterAndSize(camera.position, playerSize);

      for(const c of colliders){
        tmpBox.setFromObject(c);
        if(tmpBox.intersectsBox(playerBox)){
          // revert to previous pos
          camera.position.copy(prevPos);
          return;
        }
      }
    }

    // ========= GENERATION =========
    function generateWorld(){
      // clear old (simple approach: refresh page recommended, but we keep minimal)
      // initialize grid
      for(let x=0;x<config.mapSize;x++){
        map[x] = [];
        for(let z=0;z<config.mapSize;z++) map[x][z] = 0;
      }

      addBounds();

      // Populate
      for(let x=0;x<config.mapSize;x++){
        for(let z=0;z<config.mapSize;z++){
          const wx = x*config.scale;
          const wz = z*config.scale;

          // Keep start area clearer
          const distStart = Math.hypot(wx-8, wz-8);
          if(distStart < 12) continue;

          const r = Math.random();
          if(r > 0.86) spawnBuilding(wx, wz);
          else if(r > 0.72) spawnTree(wx, wz, Math.random()<0.28);
          else if(r > 0.66) spawnBed(wx, wz);
          else if(r > 0.62) spawnNails(wx, wz);
          else if(r > 0.58) spawnBrokenTV(wx, wz);
        }
      }

      // Name graffiti (your “cranberry drip” identity)
      for(let i=0;i<config.nameGraffitiCount;i++){
        const x = (Math.random()*(config.mapSize-6)+3)*config.scale;
        const z = (Math.random()*(config.mapSize-6)+3)*config.scale;
        spawnNameGraffiti(x, z);
      }

      // Wall scares (image.png/image2.png)
      for(let i=0;i<config.wallScareCount;i++){
        const x = (Math.random()*(config.mapSize-6)+3)*config.scale;
        const z = (Math.random()*(config.mapSize-6)+3)*config.scale;
        spawnWallScare(x, z, Math.random()<0.5 ? "image1" : "image2");
      }

      // Notes (some reduce sanity harder)
      const noteLines = [
        "The map is a polite liar.",
        "If your name appears twice, do not look for the third.",
        "The doors are not entrances. They are edits.",
        "Your breathing is not yours anymore.",
        "The rain is not water. It's a memory leak."
      ];
      for(let i=0;i<config.itemCount;i++){
        const x = (Math.random()*(config.mapSize-6)+3)*config.scale;
        const z = (Math.random()*(config.mapSize-6)+3)*config.scale;
        const creepy = 0.2 + Math.random()*0.8;
        spawnNote(x, z, "LOG " + (i+1), noteLines[(Math.random()*noteLines.length)|0], creepy);
      }

      // Key + doors (server room)
      spawnPickup(16, 16, "key");

      // A door that needs key: server room
      spawnDoor(10, 10, "SERVER ROOM", ()=>{
        if(!state.hasKey){
          speak("ACCESS DENIED.");
          addSanity(-8);
          // close itself by reloading page? keep simple: punish
          return;
        }
        // Win-ish moment
        speak(`Welcome, ${state.playerName}. You were expected.`);
        document.getElementById("quest-log").innerHTML = "OBJECTIVE: SURVIVE THE DOWNLOAD.<br/>THE SERVER IS LOOKING AT YOU.";
        // Spawn extra enemies as “ending pressure”
        for(let i=0;i<4;i++){
          if(enemies.length < config.maxEnemies) spawnEnemy();
        }
      });

      // Mysterious pathways: pocket doors teleport you
      for(let i=0;i<config.pocketRooms;i++){
        const x = (Math.random()*(config.mapSize-10)+5)*config.scale;
        const z = (Math.random()*(config.mapSize-10)+5)*config.scale;
        spawnDoor(x, z, "MAINTENANCE", ()=>{
          // teleport pocket (small safe-ish chamber)
          const px = Math.random()*(config.mapSize*config.scale-20)+10;
          const pz = Math.random()*(config.mapSize*config.scale-20)+10;
          camera.position.set(px, 1.7, pz);
          addSanity(+6); // sometimes relief
          state.glitch = Math.max(0, state.glitch - 0.12);
          // chance for an easter egg
          if(Math.random() < 0.35){
            speak(`You found a place the city forgot.`);
            spawnPickup(px + 2, pz, Math.random()<0.5 ? "pipe" : "shard");
          }
        });
      }

      // Enemies (PNG monsters)
      for(let i=0;i<config.enemyCount;i++) spawnEnemy();

      // Also: a “nice” trap background (the meadow) appears when sanity is low (artistic dissonance)
      // We'll swap sky texture sometimes in loop.
    }

    // ========= INPUT + MOVEMENT (FIXED) =========
    const clock = new THREE.Clock();
    const vel = new THREE.Vector3();
    let moveF=false, moveB=false, moveL=false, moveR=false, sprint=false, canJump=false;

    function onKeyDown(e){
      if(e.code === "KeyW") moveF = true;
      if(e.code === "KeyS") moveB = true;  // FIXED: S is backward
      if(e.code === "KeyA") moveL = true;
      if(e.code === "KeyD") moveR = true;
      if(e.code === "ShiftLeft" || e.code === "ShiftRight") sprint = true;

      if(e.code === "Space"){
        if(canJump){
          vel.y = 6.2;
          canJump = false;
        }
      }

      if(e.code === "KeyE"){
        if(currentTarget) currentTarget.action();
      }

      if(e.code === "KeyT"){
        speak(`${state.playerName}. do you remember why you came?`);
      }
    }
    function onKeyUp(e){
      if(e.code === "KeyW") moveF = false;
      if(e.code === "KeyS") moveB = false;
      if(e.code === "KeyA") moveL = false;
      if(e.code === "KeyD") moveR = false;
      if(e.code === "ShiftLeft" || e.code === "ShiftRight") sprint = false;
    }

    document.addEventListener("keydown", onKeyDown);
    document.addEventListener("keyup", onKeyUp);

    document.addEventListener("mousedown", async (e)=>{
      if(!state.isPlaying) return;
      await ensureAudio();
      if(!controls.isLocked){
        controls.lock();
        return;
      }
      if(e.button === 0){
        tryAttack();
      }
    });

    // ========= LOOP =========
    function applySanityAtmosphere(dt){
      const s = state.sanity / 100;
      const fear = 1 - s;

      // Lights dim with sanity loss
      hemi.intensity = lerp(0.22, 0.9, s);
      keyLight.intensity = lerp(0.18, 0.9, s);

      // Fog thickens
      scene.fog.density = lerp(0.07, 0.018, s);

      // Flashlight gets “twitchy” when low sanity
      flashlight.intensity = lerp(2.6, 1.7, s) + Math.sin(performance.now()*0.008) * fear * 0.25;

      // Overlays
      vignette.style.opacity = String(lerp(0.62, 0.12, s));
      scanlines.style.opacity = String(lerp(0.26, 0.08, s));
      noiseOverlay.style.opacity = String(lerp(0.28, 0.00, s) * (0.55 + Math.random()*0.45));

      // Renderer filter (subtle PS2 + glitch)
      const g = clamp01(state.glitch + fear*0.35);
      const hue = (fear > 0.55) ? (Math.random()*18 - 9) : 0;
      const inv = (fear > 0.75 && Math.random() < 0.06) ? 1 : 0;
      renderer.domElement.style.filter =
        `contrast(${1.05 + g*0.45}) saturate(${1.06 - fear*0.35}) blur(${g*0.35}px) hue-rotate(${hue}deg) ${inv ? "invert(1)" : ""}`;

      // Occasionally swap sky to “meadow” (your bright field) when sanity is low => uncanny contrast
      if(fear > 0.62 && (loaded.back && Math.random() < 0.01)){
        sky.material.map = loaded.back;
        sky.material.needsUpdate = true;
      } else if(fear < 0.5 && loaded.back2){
        sky.material.map = loaded.back2;
        sky.material.needsUpdate = true;
      }

      // Audio changes with sanity
      if(audioCtx && droneGain){
        droneGain.gain.value = lerp(0.28, 0.12, s) + fear*0.10;
        // “wobble” pitch
        if(droneOsc){
          droneOsc.frequency.setValueAtTime(lerp(35, 46, s) + Math.sin(performance.now()*0.0016)*fear*4, audioCtx.currentTime);
        }
        // master volume a bit tighter when fear high
        master.gain.value = lerp(0.62, 0.48, fear);
      }
    }

    function enemyAI(dt){
      const player = camera.position;
      const s = state.sanity/100;
      const fear = 1-s;

      for(const e of enemies){
        e.phase += dt;

        // always face camera (billboard)
        // sprite already faces camera, but we can “shiver”
        const shiver = (Math.sin(e.phase*12.0) * 0.04) * (0.25 + fear);
        e.mesh.position.y = 1.8 + shiver;

        const d = e.mesh.position.distanceTo(player);
        const chaseRange = 18 + fear*10;
        const hitRange = 1.7;

        // become more aggressive as sanity drops
        const aggressive = (fear > 0.4) ? 1.0 : 0.75;

        if(d < chaseRange){
          // move toward player
          const dir = new THREE.Vector3().subVectors(player, e.mesh.position);
          dir.y = 0;
          dir.normalize();

          const sp = e.speed * aggressive * (0.6 + e.aggro);
          e.mesh.position.add(dir.multiplyScalar(sp * dt));

          // distortion at close range
          if(d < 6){
            e.mesh.material.opacity = 0.86 + Math.sin(performance.now()*0.02)*0.12;
            if(Math.random() < 0.02*fear) state.glitch = Math.min(1, state.glitch + 0.08);
          }

          // damage
          if(d < hitRange){
            addHP(-12 * dt);
            addSanity(-(7 * dt));
            if(Math.random() < 0.01){
              speak(`${state.playerName}…`);
            }
          }
          e.aggro = Math.min(1, e.aggro + dt*0.2);
        } else {
          // wander
          e.mesh.position.x += Math.sin(e.phase*0.7 + e.phase*0.1) * dt * 0.4;
          e.mesh.position.z += Math.cos(e.phase*0.8) * dt * 0.4;
          e.aggro = Math.max(0, e.aggro - dt*0.15);
          e.mesh.material.opacity = 0.98;
        }
      }

      // spawn reinforcements if you stay too long (keeps tension)
      if(state.timeAlive > 70 && enemies.length < config.maxEnemies && Math.random() < 0.003 + fear*0.003){
        spawnEnemy();
      }
    }

    function animate(){
      requestAnimationFrame(animate);
      if(!state.isPlaying) return;

      const dt = Math.min(0.033, clock.getDelta());
      state.timeAlive += dt;
      state.ttsCooldown = Math.max(0, state.ttsCooldown - dt);

      // sanity drains slowly over time (more if running)
      const drain = 0.55 + (sprint ? 0.25 : 0) + (state.glitch*0.65);
      addSanity(-drain * dt);

      // glitch relaxes slowly
      state.glitch = Math.max(0, state.glitch - dt*0.06);

      // atmosphere changes
      applySanityAtmosphere(dt);

      // weather
      updateWeather(dt);

      // minimap (and lies)
      drawMinimap();

      // interaction
      checkInteraction();

      // move
      if(controls.isLocked){
        const prev = camera.position.clone();

        // gravity
        vel.y -= 14.0 * dt;

        const speed = (sprint ? 7.0 : 4.7) * (0.82 + (state.sanity/100)*0.18);
        const forward = (moveF ? 1 : 0) - (moveB ? 1 : 0); // FIXED
        const right = (moveR ? 1 : 0) - (moveL ? 1 : 0);

        // friction
        vel.x *= (1 - 8*dt);
        vel.z *= (1 - 8*dt);

        // apply input
        vel.z -= forward * speed * 9.0 * dt;
        vel.x -= right * speed * 9.0 * dt;

        controls.moveForward(-vel.z * dt);
        controls.moveRight(-vel.x * dt);

        camera.position.y += vel.y * dt;

        // floor
        if(camera.position.y < 1.7){
          camera.position.y = 1.7;
          vel.y = 0;
          canJump = true;
        }

        // collision resolve
        resolveCollisions(prev);

        // head bob (responsive)
        if(Math.abs(forward) + Math.abs(right) > 0){
          const bob = Math.sin(state.timeAlive*10.5) * 0.035 * (sprint ? 1.25 : 1.0);
          camera.position.y += bob;
        }
      }

      // animate name graffiti
      for(const d of decals){
        d.tick(state.timeAlive + d.wobble);
        // subtle pulse when sanity low
        const s = state.sanity/100;
        d.mesh.material.opacity = lerp(0.98, 0.78, 1-s) + Math.sin(state.timeAlive*2.0 + d.wobble)*0.03;
      }

      // enemies
      enemyAI(dt);

      // TV flicker (if present)
      for(const it of interactables){
        if(it.mesh?.userData?.type === "tv"){
          const tv = it.mesh;
          const u = tv.userData;
          if(u.light){
            u.light.intensity = 0.6 + Math.random()*0.9;
          }
          if(u.screen?.material?.map){
            u.screen.material.map.offset.set(Math.random()*0.02, Math.random()*0.02);
          }
        }
      }

      // render
      renderer.render(scene, camera);

      // death
      if(state.hp <= 0 || state.sanity <= 0){
        state.isPlaying = false;
        document.exitPointerLock?.();
        document.getElementById("death-screen").style.display = "flex";
        document.getElementById("death-reason").innerText =
          (state.hp <= 0) ? "PHYSICAL TRAUMA CRITICAL" : "SYSTEM CORRUPTION 100% — YOU BELIEVED THE WALLS.";
      }
    }

    // ========= START =========
    document.getElementById("start-btn").addEventListener("click", async ()=>{
      const input = document.getElementById("name-input").value.trim();
      state.playerName = input ? input.toUpperCase() : "NO-ONE";
      updateBars();

      document.getElementById("start-screen").style.display = "none";
      state.isPlaying = true;

      // world + start
      generateWorld();
      camera.position.set(6, 1.7, 6);

      await ensureAudio();
      controls.lock();

      speak(`Welcome, ${state.playerName}.`);
      animate();
    });

    window.addEventListener("resize", ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // Start with stable mouse: no roll jitter (we never add camera.rotation.z now)
    // If you want even smoother feel, you can lower pointer speed by scaling movement (handled by browser).
  </script>
</body>
</html>





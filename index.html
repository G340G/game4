<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GLITCH CITY: SECTOR 0</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        
        /* UI LAYERS */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        /* HUD */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 12px; height: 12px;
            border: 2px solid rgba(255,255,255,0.8); border-radius: 50%;
            transform: translate(-50%, -50%); transition: 0.2s;
        }
        .interact-active { border-color: #0f0 !important; background: rgba(0,255,0,0.3); width: 20px !important; height: 20px !important; }
        
        #stats { position: absolute; bottom: 20px; left: 20px; color: #fff; font-size: 20px; text-shadow: 2px 2px 0 #000; }
        .stat-bar { width: 200px; height: 15px; background: #333; margin-top: 5px; border: 1px solid #fff; }
        .fill { height: 100%; transition: width 0.3s; }
        #hp-bar { background: #d00; width: 100%; }
        #san-bar { background: #00d; width: 100%; }

        #minimap-container {
            position: absolute; top: 20px; right: 20px;
            width: 150px; height: 150px; background: rgba(0,0,0,0.5);
            border: 2px solid #fff; border-radius: 50%; overflow: hidden;
        }
        #minimap { width: 100%; height: 100%; opacity: 0.8; }

        #interaction-text {
            position: absolute; top: 60%; left: 50%; transform: translateX(-50%);
            color: #ff0; font-size: 24px; font-weight: bold; text-shadow: 1px 1px 0 #000;
            display: none;
        }

        /* OVERLAYS */
        #note-overlay {
            display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 400px; background: #fff; color: #000; padding: 20px; font-family: 'Times New Roman';
            border: 10px solid #222; box-shadow: 0 0 50px #000; pointer-events: auto; text-align: center;
        }
        
        #start-screen, #death-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 20; color: #fff; pointer-events: auto;
        }
        button {
            padding: 15px 30px; font-size: 1.5em; background: #d00; color: #fff; 
            border: none; cursor: pointer; margin-top: 20px; font-family: 'Courier New';
        }
        button:hover { background: #f00; box-shadow: 0 0 20px #f00; }

        .glitch-text { animation: glitch 0.3s infinite; }
        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(-2px, -2px); }
            60% { transform: translate(2px, 2px); }
            80% { transform: translate(2px, -2px); }
            100% { transform: translate(0); }
        }

    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="crosshair"></div>
        <div id="minimap-container"><canvas id="minimap"></canvas></div>
        <div id="stats">
            <div>DATA INTEGRITY (HP)</div>
            <div class="stat-bar"><div id="hp-bar" class="fill"></div></div>
            <div>LOGIC STABILITY (SANITY)</div>
            <div class="stat-bar"><div id="san-bar" class="fill"></div></div>
            <div id="quest-log" style="margin-top:10px; font-size: 16px; color:#aaa;">OBJECTIVE: FIND THE SERVER ROOM KEY</div>
        </div>
        <div id="interaction-text">PRESS [E] TO INTERACT</div>
    </div>

    <div id="note-overlay">
        <h2 id="note-title">NOTE</h2>
        <p id="note-content">...</p>
        <button onclick="closeNote()">PUT AWAY</button>
    </div>

    <div id="start-screen">
        <h1 class="glitch-text" style="font-size: 4em; color: #f00;">GLITCH CITY</h1>
        <p>SECTOR 7 IS CORRUPTED. IT RAINS DATA.</p>
        <p>WASD to Move | SHIFT to Run | E to Interact | SPACE to Jump</p>
        <p>Free the caged data. Avoid the Firewalls (Zombies). Eat carefully.</p>
        <button id="start-btn">ENTER SIMULATION</button>
    </div>

    <div id="death-screen" style="display:none;">
        <h1 style="color:red">CONNECTION LOST</h1>
        <p id="death-reason"></p>
        <button onclick="location.reload()">RESPAWN</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- GAME CONFIG ---
        const config = {
            mapSize: 40, // 40x40 grid
            scale: 4,    // Unit size
            enemyCount: 8,
            npcCount: 5,
            itemCount: 15
        };

        let state = {
            hp: 100,
            sanity: 100,
            isPlaying: false,
            inventory: [],
            weather: 'rain',
            level: 1,
            glitchMode: 0 // 0 = none, 1 = light, 2 = heavy
        };

        // --- ASSET GENERATOR (PROCEDURAL TEXTURES) ---
        // Generates textures on the fly so we don't need external files
        const textures = {};

        function createTexture(type, color1, color2) {
            const size = 512;
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');

            // Base
            ctx.fillStyle = color1;
            ctx.fillRect(0,0,size,size);

            if(type === 'noise') {
                for(let i=0; i<10000; i++) {
                    ctx.fillStyle = Math.random() > 0.5 ? color2 : '#000';
                    ctx.globalAlpha = 0.1;
                    ctx.fillRect(Math.random()*size, Math.random()*size, 2, 2);
                }
            } else if (type === 'brick') {
                ctx.strokeStyle = color2;
                ctx.lineWidth = 4;
                for(let y=0; y<size; y+=64) {
                    for(let x=0; x<size; x+=128) {
                        const offset = (y/64)%2 === 0 ? 0 : 64;
                        ctx.strokeRect(x+offset, y, 128, 64);
                        // Grime
                        if(Math.random()>0.5) {
                            ctx.fillStyle = 'rgba(0,0,0,0.2)';
                            ctx.fillRect(x+offset + 10, y+10, 100, 40);
                        }
                    }
                }
            } else if (type === 'static') {
                for(let i=0; i<50000; i++) {
                    ctx.fillStyle = `rgba(${Math.random()*255},${Math.random()*255},${Math.random()*255},1)`;
                    ctx.fillRect(Math.random()*size, Math.random()*size, 2, 2);
                }
            } else if (type === 'wood') {
                ctx.strokeStyle = color2;
                ctx.lineWidth = 2;
                for(let i=0; i<size; i+=5) {
                    ctx.beginPath();
                    ctx.moveTo(0, i + Math.random()*10);
                    ctx.lineTo(size, i + Math.random()*10);
                    ctx.stroke();
                }
            }

            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        // Generate Library
        textures.concrete = createTexture('noise', '#444', '#222');
        textures.brick = createTexture('brick', '#522', '#300'); // Red brick
        textures.grass = createTexture('noise', '#131', '#050');
        textures.wood = createTexture('wood', '#532', '#321');
        textures.static = createTexture('static', '#000', '#fff');
        textures.sky = createTexture('noise', '#050510', '#112');

        // --- 3D ENGINE SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510);
        scene.fog = new THREE.FogExp2(0x050510, 0.04);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Lighting
        const hemiLight = new THREE.HemisphereLight(0x444455, 0x111122, 0.4);
        scene.add(hemiLight);

        const moonLight = new THREE.DirectionalLight(0xaaccff, 0.3);
        moonLight.position.set(50, 100, 50);
        moonLight.castShadow = true;
        scene.add(moonLight);

        const flashLight = new THREE.SpotLight(0xffffee, 2, 40, Math.PI/5, 0.5, 1);
        flashLight.position.set(0,0,0);
        flashLight.target.position.set(0,0,-1);
        camera.add(flashLight);
        camera.add(flashLight.target);
        scene.add(camera);

        const controls = new PointerLockControls(camera, document.body);

        // --- MAP GENERATION ---
        const map = []; // 2D grid
        const colliders = [];
        const interactables = [];
        const enemies = [];
        
        function generateCity() {
            // Init empty
            for(let x=0; x<config.mapSize; x++) {
                map[x] = [];
                for(let z=0; z<config.mapSize; z++) {
                    map[x][z] = 0; // 0 = Ground
                }
            }

            // Create Roads (Grid)
            for(let x=2; x<config.mapSize; x+=4) {
                for(let z=0; z<config.mapSize; z++) map[x][z] = 1; // 1 = Road
            }
            for(let z=2; z<config.mapSize; z+=4) {
                for(let x=0; x<config.mapSize; x++) map[x][z] = 1; 
            }

            // Ground Plane
            const planeGeo = new THREE.PlaneGeometry(config.mapSize*config.scale, config.mapSize*config.scale);
            const planeMat = new THREE.MeshStandardMaterial({ map: textures.grass, roughness: 1 });
            const ground = new THREE.Mesh(planeGeo, planeMat);
            ground.rotation.x = -Math.PI/2;
            ground.position.set(config.mapSize*config.scale/2, 0, config.mapSize*config.scale/2);
            ground.receiveShadow = true;
            scene.add(ground);

            // Populate Blocks
            for(let x=0; x<config.mapSize; x++) {
                for(let z=0; z<config.mapSize; z++) {
                    const wx = x * config.scale;
                    const wz = z * config.scale;

                    if(map[x][z] === 0) {
                        // Not a road, spawn stuff
                        const r = Math.random();
                        if(r > 0.7) spawnBuilding(wx, wz);
                        else if (r > 0.4) spawnTree(wx, wz);
                        else if (r > 0.35) spawnBrokenTV(wx, wz);
                    }
                }
            }

            // Walls around city
            const wallGeo = new THREE.BoxGeometry(config.mapSize*config.scale, 20, 1);
            const wallMat = new THREE.MeshStandardMaterial({ color: 0x000 });
            const w1 = new THREE.Mesh(wallGeo, wallMat); w1.position.set(80, 10, -1); scene.add(w1); colliders.push(w1);
            const w2 = new THREE.Mesh(wallGeo, wallMat); w2.position.set(80, 10, 161); scene.add(w2); colliders.push(w2);
            const w3 = new THREE.Mesh(new THREE.BoxGeometry(1, 20, 160), wallMat); w3.position.set(-1, 10, 80); scene.add(w3); colliders.push(w3);
            const w4 = new THREE.Mesh(new THREE.BoxGeometry(1, 20, 160), wallMat); w4.position.set(161, 10, 80); scene.add(w4); colliders.push(w4);

            // Spawn Special Items
            spawnDoor(10, 10, "SERVER ROOM");
            spawnNote(15, 15, "WELCOME", "The city is glitching. Find food. Avoid the red eyes.");
            spawnCage(20, 20);
            
            // Random Items
            for(let i=0; i<config.itemCount; i++) {
                const rx = Math.floor(Math.random()*config.mapSize)*config.scale;
                const rz = Math.floor(Math.random()*config.mapSize)*config.scale;
                if(Math.random()>0.5) spawnFood(rx, rz, Math.random()>0.7); // 30% bad food
                else spawnNote(rx, rz, "LOG " + i, "They are watching. Don't stop moving.");
            }

            // Enemies
            for(let i=0; i<config.enemyCount; i++) {
                spawnEnemy();
            }
        }

        // --- PREFABS ---

        function spawnBuilding(x, z) {
            const h = 5 + Math.random() * 10;
            const geo = new THREE.BoxGeometry(3, h, 3);
            const mat = new THREE.MeshStandardMaterial({ map: textures.brick });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, h/2, z);
            mesh.castShadow = true;
            scene.add(mesh);
            colliders.push(mesh);
            map[x/config.scale][z/config.scale] = 2; // Building on map
        }

        function spawnTree(x, z) {
            const trunkG = new THREE.CylinderGeometry(0.3, 0.4, 3);
            const trunkM = new THREE.MeshStandardMaterial({ map: textures.wood });
            const trunk = new THREE.Mesh(trunkG, trunkM);
            trunk.position.set(x, 1.5, z);
            
            const leavesG = new THREE.ConeGeometry(2, 4, 8);
            const leavesM = new THREE.MeshStandardMaterial({ color: 0x224422 });
            const leaves = new THREE.Mesh(leavesG, leavesM);
            leaves.position.y = 2.5;
            trunk.add(leaves);
            
            scene.add(trunk);
            colliders.push(trunk);
        }

        function spawnBrokenTV(x, z) {
            const geo = new THREE.BoxGeometry(1, 0.8, 0.8);
            const mat = new THREE.MeshStandardMaterial({ color: 0x333 });
            const tv = new THREE.Mesh(geo, mat);
            tv.position.set(x, 0.4, z);
            
            const screenG = new THREE.PlaneGeometry(0.9, 0.7);
            const screenM = new THREE.MeshBasicMaterial({ map: textures.static });
            const screen = new THREE.Mesh(screenG, screenM);
            screen.position.z = 0.41;
            tv.add(screen);
            
            // Add light flicker
            const light = new THREE.PointLight(0xaaffff, 1, 3);
            light.position.z = 1;
            tv.add(light);
            
            tv.userData = { type: 'tv', light: light };
            scene.add(tv);
            colliders.push(tv);
        }

        function spawnDoor(x, z, label) {
            const doorGeo = new THREE.BoxGeometry(2, 4, 0.2);
            const doorMat = new THREE.MeshStandardMaterial({ map: textures.wood, color: 0x553333 });
            const door = new THREE.Mesh(doorGeo, doorMat);
            door.position.set(x, 2, z);
            scene.add(door);
            colliders.push(door);
            
            interactables.push({
                mesh: door,
                text: "OPEN " + label,
                action: () => {
                    // Animation
                    let open = false;
                    const interval = setInterval(() => {
                        door.rotation.y += 0.1;
                        if(door.rotation.y > Math.PI/2) clearInterval(interval);
                    }, 16);
                    // Remove collider
                    const idx = colliders.indexOf(door);
                    if(idx > -1) colliders.splice(idx, 1);
                }
            });
        }

        function spawnFood(x, z, isRotten) {
            const geo = new THREE.DodecahedronGeometry(0.3);
            const mat = new THREE.MeshStandardMaterial({ color: isRotten ? 0x00ff00 : 0xffaa00, emissive: 0x222222 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, 0.5, z);
            scene.add(mesh);
            
            interactables.push({
                mesh: mesh,
                text: isRotten ? "EAT GLITCHED MEAT" : "EAT DATA PACK",
                action: () => {
                    scene.remove(mesh);
                    if(isRotten) {
                        state.glitchMode = 2;
                        state.sanity -= 20;
                        setTimeout(() => state.glitchMode = 0, 5000); // Glitch for 5s
                    } else {
                        state.hp = Math.min(100, state.hp + 20);
                        state.sanity = Math.min(100, state.sanity + 10);
                    }
                }
            });
        }

        function spawnNote(x, z, title, content) {
            const geo = new THREE.PlaneGeometry(0.5, 0.6);
            const mat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = -Math.PI/2;
            mesh.position.set(x, 0.05, z);
            scene.add(mesh);
            
            interactables.push({
                mesh: mesh,
                text: "READ NOTE",
                action: () => {
                    document.getElementById('note-overlay').style.display = 'block';
                    document.getElementById('note-title').innerText = title;
                    document.getElementById('note-content').innerText = content;
                    document.exitPointerLock();
                }
            });
        }

        function spawnCage(x, z) {
            const cageGeo = new THREE.BoxGeometry(1, 1, 1);
            const cageMat = new THREE.MeshBasicMaterial({ color: 0xaaaaaa, wireframe: true });
            const cage = new THREE.Mesh(cageGeo, cageMat);
            cage.position.set(x, 0.5, z);
            
            const animalGeo = new THREE.SphereGeometry(0.3);
            const animalMat = new THREE.MeshStandardMaterial({ color: 0xffaaaa });
            const animal = new THREE.Mesh(animalGeo, animalMat);
            cage.add(animal);
            
            scene.add(cage);
            colliders.push(cage);
            
            interactables.push({
                mesh: cage,
                text: "FREE ENTITY",
                action: () => {
                    scene.remove(cage);
                    state.sanity = Math.min(100, state.sanity + 30); // Good karma
                    const idx = colliders.indexOf(cage);
                    if(idx > -1) colliders.splice(idx, 1);
                }
            });
        }

        function spawnEnemy() {
            // Zombie / Firewall
            const geo = new THREE.BoxGeometry(0.8, 1.8, 0.8);
            const mat = new THREE.MeshStandardMaterial({ color: 0x220000 });
            const mesh = new THREE.Mesh(geo, mat);
            
            // Glowing red eyes
            const eyeG = new THREE.BoxGeometry(0.2, 0.1, 0.1);
            const eyeM = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const eye1 = new THREE.Mesh(eyeG, eyeM); eye1.position.set(-0.2, 0.6, 0.4);
            const eye2 = new THREE.Mesh(eyeG, eyeM); eye2.position.set(0.2, 0.6, 0.4);
            mesh.add(eye1); mesh.add(eye2);

            // Random position
            mesh.position.set(Math.random()*150, 0.9, Math.random()*150);
            scene.add(mesh);
            
            enemies.push({
                mesh: mesh,
                speed: 2 + Math.random() * 2,
                state: 'idle'
            });
        }

        // --- SYSTEMS ---

        // Rain System
        const rainCount = 10000;
        const rainGeo = new THREE.BufferGeometry();
        const rainPos = new Float32Array(rainCount * 3);
        for(let i=0; i<rainCount*3; i+=3) {
            rainPos[i] = Math.random() * 200 - 20;
            rainPos[i+1] = Math.random() * 100;
            rainPos[i+2] = Math.random() * 200 - 20;
        }
        rainGeo.setAttribute('position', new THREE.BufferAttribute(rainPos, 3));
        const rainMat = new THREE.PointsMaterial({ color: 0xaaaaaa, size: 0.1, transparent: true });
        const rainSystem = new THREE.Points(rainGeo, rainMat);
        scene.add(rainSystem);

        function updateWeather() {
            const positions = rainSystem.geometry.attributes.position.array;
            for(let i=1; i<rainCount*3; i+=3) {
                positions[i] -= 0.5;
                if(positions[i] < 0) positions[i] = 100;
            }
            rainSystem.geometry.attributes.position.needsUpdate = true;

            // Lightning
            if(Math.random() > 0.995) {
                hemiLight.intensity = 2.0;
                setTimeout(() => hemiLight.intensity = 0.4, 100);
            }
        }

        // Minimap
        const mapCanvas = document.getElementById('minimap');
        const mapCtx = mapCanvas.getContext('2d');
        function updateMinimap() {
            mapCtx.fillStyle = '#000';
            mapCtx.fillRect(0,0,300,150);
            
            const px = camera.position.x;
            const pz = camera.position.z;
            const scale = 2; // Map zoom
            
            // Draw player
            mapCtx.fillStyle = '#0f0';
            mapCtx.beginPath();
            mapCtx.arc(75, 75, 4, 0, Math.PI*2);
            mapCtx.fill();

            // Draw nearby buildings
            mapCtx.fillStyle = '#555';
            colliders.forEach(obj => {
                const relX = (obj.position.x - px) * scale + 75;
                const relY = (obj.position.z - pz) * scale + 75;
                if(relX > 0 && relX < 150 && relY > 0 && relY < 150) {
                    mapCtx.fillRect(relX-2, relY-2, 4, 4);
                }
            });
            
            // Enemies
            mapCtx.fillStyle = '#f00';
            enemies.forEach(e => {
                const relX = (e.mesh.position.x - px) * scale + 75;
                const relY = (e.mesh.position.z - pz) * scale + 75;
                if(relX > 0 && relX < 150 && relY > 0 && relY < 150) {
                    mapCtx.fillRect(relX-2, relY-2, 4, 4);
                }
            });
        }

        // Interaction Raycaster
        const raycaster = new THREE.Raycaster();
        let currentTarget = null;

        function checkInteraction() {
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const intersects = raycaster.intersectObjects(interactables.map(i => i.mesh));
            
            if(intersects.length > 0 && intersects[0].distance < 4) {
                const obj = intersects[0].object;
                const data = interactables.find(i => i.mesh === obj);
                if(data) {
                    document.getElementById('crosshair').classList.add('interact-active');
                    document.getElementById('interaction-text').style.display = 'block';
                    document.getElementById('interaction-text').innerText = "[E] " + data.text;
                    currentTarget = data;
                }
            } else {
                document.getElementById('crosshair').classList.remove('interact-active');
                document.getElementById('interaction-text').style.display = 'none';
                currentTarget = null;
            }
        }

        // --- MAIN LOOP ---
        const clock = new THREE.Clock();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let moveF = false, moveB = false, moveL = false, moveR = false, canJump = false;

        function animate() {
            requestAnimationFrame(animate);

            if(!state.isPlaying) return;

            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // 1. Weather
            updateWeather();
            updateMinimap();

            // 2. Player Movement
            if(controls.isLocked) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 2.0 * delta; // Gravity

                direction.z = Number(moveF) - Number(moveB);
                direction.x = Number(moveR) - Number(moveL);
                direction.normalize();

                if (moveF || moveB) velocity.z -= direction.z * 100.0 * delta;
                if (moveL || moveR) velocity.x -= direction.x * 100.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                camera.position.y += velocity.y * delta; // Fall

                // Floor check
                if (camera.position.y < 1.7) {
                    velocity.y = 0;
                    camera.position.y = 1.7;
                    canJump = true;
                }

                // Wall Collision (Simple)
                // We check if player is inside a collider box
                const pPos = camera.position;
                colliders.forEach(c => {
                    const box = new THREE.Box3().setFromObject(c);
                    // Shrink box slightly for leeway
                    if(box.containsPoint(pPos)) {
                        // Push back
                        controls.moveForward(1); 
                    }
                });

                // Head Bob
                if(moveF || moveB || moveL || moveR) {
                    camera.position.y += Math.sin(time * 10) * 0.05;
                }
            }

            // 3. Enemy AI
            enemies.forEach(e => {
                const dist = e.mesh.position.distanceTo(camera.position);
                
                if(dist < 20) {
                    // Chase
                    e.mesh.lookAt(camera.position.x, 0.9, camera.position.z);
                    e.mesh.translateZ(e.speed * delta);
                    
                    if(dist < 1.5) {
                        state.hp -= 10 * delta; // Damage
                        state.sanity -= 5 * delta;
                        document.getElementById('hp-bar').style.width = state.hp + "%";
                        document.getElementById('san-bar').style.width = state.sanity + "%";
                    }
                } else {
                    // Idle wander
                    e.mesh.rotation.y += Math.sin(time) * 0.01;
                    e.mesh.translateZ(1 * delta);
                }
            });

            // 4. Interaction
            checkInteraction();

            // 5. Glitch Effects
            if(state.glitchMode === 2) {
                document.querySelector('canvas').style.filter = `invert(1) hue-rotate(${Math.random()*360}deg)`;
                camera.rotation.z = (Math.random()-0.5) * 0.2;
            } else {
                document.querySelector('canvas').style.filter = 'none';
                camera.rotation.z = 0;
            }

            // 6. Stats Check
            if(state.hp <= 0 || state.sanity <= 0) {
                state.isPlaying = false;
                document.exitPointerLock();
                document.getElementById('death-screen').style.display = 'flex';
                document.getElementById('death-reason').innerText = state.hp<=0 ? "PHYSICAL TRAUMA CRITICAL" : "SYSTEM CORRUPTION 100%";
            }
        }

        // --- INPUTS ---
        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'KeyW': moveF = true; break;
                case 'KeyS': moveB = true; break;
                case 'KeyA': moveL = true; break;
                case 'KeyD': moveR = true; break;
                case 'Space': if(canJump) velocity.y += 15; canJump = false; break;
                case 'KeyE': 
                    if(currentTarget) currentTarget.action(); 
                    break;
            }
        });
        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': moveF = false; break;
                case 'KeyS': moveB = false; break;
                case 'KeyA': moveL = false; break;
                case 'KeyD': moveR = false; break;
            }
        });

        // Start
        document.getElementById('start-btn').addEventListener('click', () => {
            document.getElementById('start-screen').style.display = 'none';
            state.isPlaying = true;
            generateCity();
            
            // Set start pos safe
            camera.position.set(5, 1.7, 5); 
            
            controls.lock();
            animate();
        });

        window.closeNote = function() {
            document.getElementById('note-overlay').style.display = 'none';
            controls.lock();
        };

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEURO-DUMP // FATAL EXCEPTION</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Courier New', monospace; user-select: none; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        
        /* UI OVERLAY */
        #ui {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            pointer-events: none; mix-blend-mode: exclusion;
        }
        
        /* HUD ELEMENTS */
        .hud-text {
            position: absolute; color: #ff3333; font-weight: bold; font-size: 24px;
            text-shadow: 2px 0px 5px rgba(255, 0, 0, 0.8);
            letter-spacing: 2px;
        }
        #integrity { bottom: 30px; left: 30px; font-size: 30px; }
        #log { top: 30px; left: 30px; font-size: 16px; max-width: 400px; line-height: 1.4; color: #fff; text-shadow: none; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 10px; height: 10px;
            border: 2px solid rgba(255, 255, 255, 0.5); transform: translate(-50%, -50%);
            border-radius: 50%;
        }

        /* START SCREEN */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 20; display: flex; flex-direction: column;
            justify-content: center; align-items: center; pointer-events: auto;
        }
        h1 { 
            color: #fff; font-size: 6vw; text-transform: uppercase; margin: 0; 
            animation: glitch 1s infinite alternate; mix-blend-mode: difference;
        }
        p { color: #888; margin-top: 20px; font-size: 1.2rem; max-width: 600px; text-align: center; }
        button {
            margin-top: 50px; padding: 20px 40px; background: transparent; border: 2px solid #fff;
            color: #fff; font-size: 1.5rem; cursor: pointer; font-family: 'Courier New';
            transition: 0.2s; text-transform: uppercase;
        }
        button:hover { background: #fff; color: #000; box-shadow: 0 0 20px #fff; }

        @keyframes glitch {
            0% { transform: skew(0deg); }
            20% { transform: skew(-10deg); filter: blur(2px); }
            40% { transform: skew(10deg); }
            60% { transform: skew(0deg); opacity: 1; }
            80% { opacity: 0.5; }
            100% { transform: skew(0deg); opacity: 1; }
        }

        /* DEATH SCREEN */
        #death-screen {
            display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #200; z-index: 30; flex-direction: column;
            justify-content: center; align-items: center;
        }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1>NEURO-DUMP</h1>
        <p>You are a corrupted file scheduled for deletion.<br>Navigate the memory sectors. Avoid the Garbage Collector.<br>Find the Monolith to upload yourself.</p>
        <p style="font-size:0.8rem; color:#444;">(WEARING HEADPHONES IS MANDATORY FOR SPATIAL AUDIO)</p>
        <button id="btn-start">EXECUTE</button>
    </div>

    <div id="death-screen">
        <h1 style="color:red">DELETED</h1>
        <button onclick="location.reload()">REBOOT</button>
    </div>

    <div id="ui">
        <div id="crosshair"></div>
        <div id="integrity">INTEGRITY: 100%</div>
        <div id="log">SYSTEM: WAITING FOR USER INPUT...</div>
    </div>

    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';

        // --- GLOBAL CONFIG ---
        const SEED = Math.floor(Math.random() * 10000);
        console.log("GENERATION SEED:", SEED);

        const config = {
            mazeSize: 25, // Large maze
            wallHeight: 5,
            moveSpeed: 6.0,
            runSpeed: 10.0,
            entitySpeed: 3.5
        };

        let state = {
            sanity: 100,
            isPlaying: false,
            dead: false,
            flashOn: true,
            hasKey: false
        };

        // --- ASSET GENERATION (The "Professional" Look) ---
        // We use Lorem Picsum for textures to ensure "Real Internet Images"
        // We use a loader manager to handle the asynchronous nature.
        const loader = new THREE.TextureLoader();
        const textureCache = {};
        
        function loadTextures() {
            // Concrete Wall
            textureCache.wall = loader.load(`https://picsum.photos/seed/${SEED + 1}/512/512?grayscale`);
            textureCache.wall.wrapS = THREE.RepeatWrapping;
            textureCache.wall.wrapT = THREE.RepeatWrapping;
            
            // Floor (Grime)
            textureCache.floor = loader.load(`https://picsum.photos/seed/${SEED + 2}/512/512?blur=2&grayscale`);
            textureCache.floor.wrapS = THREE.RepeatWrapping;
            textureCache.floor.wrapT = THREE.RepeatWrapping;
            
            // The Entity Face (Glitch)
            textureCache.entity = loader.load(`https://picsum.photos/seed/${SEED + 666}/512/512`);
            
            // NPC Faces (Real people portraits)
            textureCache.npc = [];
            for(let i=0; i<3; i++) {
                textureCache.npc.push(loader.load(`https://picsum.photos/seed/${SEED + 100 + i}/200/300`));
            }
        }
        loadTextures();

        // --- AUDIO ENGINE (Avant-Garde/Industrial) ---
        // Pure WebAudio API. No files.
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const masterGain = audioCtx.createGain();
        masterGain.connect(audioCtx.destination);
        masterGain.gain.value = 0.5;

        // Reverb Simulation (The "Empty Hall" sound)
        const convolver = audioCtx.createConvolver();
        const reverbBuffer = audioCtx.createBuffer(2, audioCtx.sampleRate * 3, audioCtx.sampleRate);
        for (let channel = 0; channel < 2; channel++) {
            const nowBuff = reverbBuffer.getChannelData(channel);
            for (let i = 0; i < reverbBuffer.length; i++) {
                // Exponential decay noise
                nowBuff[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / reverbBuffer.length, 2);
            }
        }
        convolver.buffer = reverbBuffer;
        convolver.connect(masterGain);

        let droneOsc, lfo;

        function startAudio() {
            if(audioCtx.state === 'suspended') audioCtx.resume();
            
            // 1. The Low Drone (The "Server Hum")
            droneOsc = audioCtx.createOscillator();
            droneOsc.type = 'sawtooth';
            droneOsc.frequency.value = 50;
            const droneFilter = audioCtx.createBiquadFilter();
            droneFilter.type = 'lowpass';
            droneFilter.frequency.value = 120;
            
            // LFO for instability
            lfo = audioCtx.createOscillator();
            lfo.frequency.value = 0.2;
            const lfoGain = audioCtx.createGain();
            lfoGain.gain.value = 10;
            lfo.connect(lfoGain).connect(droneOsc.frequency);
            lfo.start();

            const droneGain = audioCtx.createGain();
            droneGain.gain.value = 0.3;
            
            droneOsc.connect(droneFilter).connect(droneGain).connect(convolver);
            droneOsc.start();

            // 2. High Pitch "Tinnitus" (Anxiety)
            const tinOsc = audioCtx.createOscillator();
            tinOsc.type = 'sine';
            tinOsc.frequency.value = 12000;
            const tinGain = audioCtx.createGain();
            tinGain.gain.value = 0.01;
            tinOsc.connect(tinGain).connect(audioCtx.destination); // Bypass reverb
            tinOsc.start();
        }

        function playSound(type) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain).connect(convolver);
            
            const now = audioCtx.currentTime;
            
            if (type === 'step') {
                osc.frequency.setValueAtTime(100, now);
                osc.frequency.exponentialRampToValueAtTime(10, now + 0.1);
                gain.gain.setValueAtTime(0.2, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                osc.start(now);
                osc.stop(now + 0.1);
            } else if (type === 'scream') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.linearRampToValueAtTime(800, now + 0.2);
                osc.frequency.linearRampToValueAtTime(100, now + 0.5);
                gain.gain.setValueAtTime(0.5, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                osc.start(now);
                osc.stop(now + 0.5);
            }
        }

        // --- 3D ENGINE ---
        const container = document.getElementById('canvas-container');
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // High Perf
        container.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        // Red fog for emergency state
        scene.fog = new THREE.FogExp2(0x050000, 0.08); 

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.y = 1.7; // Eye level

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
        scene.add(ambientLight);

        const flashLight = new THREE.SpotLight(0xffffff, 2);
        flashLight.angle = Math.PI / 6;
        flashLight.penumbra = 0.5;
        flashLight.decay = 2;
        flashLight.distance = 30;
        flashLight.castShadow = true;
        camera.add(flashLight);
        flashLight.position.set(0,0,0);
        flashLight.target.position.set(0,0,-1);
        camera.add(flashLight.target);
        scene.add(camera);

        const controls = new PointerLockControls(camera, document.body);

        // --- POST PROCESSING (VHS/CRT SHADER) ---
        const composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        composer.addPass(renderPass);

        // Custom GLSL Shader for that "Found Footage" look
        const VHSShader = {
            uniforms: {
                "tDiffuse": { value: null },
                "time": { value: 0.0 },
                "distortion": { value: 0.5 } // Increases with insanity
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                }
            `,
            fragmentShader: `
                uniform sampler2D tDiffuse;
                uniform float time;
                uniform float distortion;
                varying vec2 vUv;

                float rand(vec2 co){
                    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
                }

                void main() {
                    vec2 uv = vUv;
                    // Chromatic Aberration
                    float r = texture2D(tDiffuse, uv + vec2(0.002 * distortion, 0.0)).r;
                    float g = texture2D(tDiffuse, uv).g;
                    float b = texture2D(tDiffuse, uv - vec2(0.002 * distortion, 0.0)).b;
                    
                    // Scanline
                    float scanline = sin(uv.y * 800.0 + time * 10.0) * 0.04;
                    
                    // Noise/Grain
                    float noise = rand(uv + time) * 0.1;

                    // Vignette
                    float vig = uv.x * uv.y * (1.0 - uv.x) * (1.0 - uv.y);
                    vig = pow(vig, 0.25);

                    gl_FragColor = vec4(vec3(r,g,b) - scanline + noise, 1.0) * vig;
                }
            `
        };

        const vhsPass = new ShaderPass(VHSShader);
        composer.addPass(vhsPass);

        // --- GENERATION LOGIC ---
        const walls = [];
        let floorPlan = [];
        let exitPos = new THREE.Vector3();
        let npcMeshes = [];

        function generateLevel() {
            // Maze Algorithm: Recursive Backtracker
            const s = config.mazeSize;
            floorPlan = Array(s).fill().map(() => Array(s).fill(1));
            
            const stack = [{x: 1, y: 1}];
            floorPlan[1][1] = 0;
            
            while(stack.length > 0) {
                const current = stack[stack.length-1];
                const neighbors = [];
                [[0,2], [2,0], [0,-2], [-2,0]].forEach(([dx, dy]) => {
                    const nx = current.x + dx, ny = current.y + dy;
                    if(nx > 0 && nx < s-1 && ny > 0 && ny < s-1 && floorPlan[ny][nx] === 1) {
                        neighbors.push({x: nx, y: ny, dx: dx, dy: dy});
                    }
                });

                if(neighbors.length > 0) {
                    const chosen = neighbors[Math.floor(Math.random() * neighbors.length)];
                    floorPlan[chosen.y][chosen.x] = 0;
                    floorPlan[chosen.y - chosen.dy/2][chosen.x - chosen.dx/2] = 0;
                    stack.push(chosen);
                } else {
                    stack.pop();
                }
            }

            // Build Meshes
            const geoWall = new THREE.BoxGeometry(2, config.wallHeight, 2);
            // Apply textures
            const matWall = new THREE.MeshStandardMaterial({ 
                map: textureCache.wall, 
                roughness: 0.8,
                color: 0x888888
            });
            const matFloor = new THREE.MeshStandardMaterial({ 
                map: textureCache.floor, 
                roughness: 0.9,
                color: 0x444444
            });

            // Grouping geometry to improve performance? No, simple instances for collision.
            for(let y=0; y<s; y++) {
                for(let x=0; x<s; x++) {
                    if(floorPlan[y][x] === 1) {
                        const w = new THREE.Mesh(geoWall, matWall);
                        w.position.set(x*2, config.wallHeight/2, y*2);
                        // Random wall distortion for "Garibaldine" weirdness
                        if(Math.random() > 0.9) {
                            w.rotation.y = (Math.random()-0.5) * 0.2;
                            w.scale.set(0.9 + Math.random()*0.2, 1, 0.9 + Math.random()*0.2);
                        }
                        scene.add(w);
                        walls.push(w);
                    } else {
                        // Floor
                        const f = new THREE.Mesh(new THREE.PlaneGeometry(2,2), matFloor);
                        f.rotation.x = -Math.PI/2;
                        f.position.set(x*2, 0, y*2);
                        scene.add(f);
                        // Ceiling
                        const c = f.clone();
                        c.position.y = config.wallHeight;
                        c.rotation.x = Math.PI/2;
                        scene.add(c);

                        // Spawn Decor/NPC
                        if(Math.random() < 0.05 && x>2 && y>2) spawnAnomaly(x*2, y*2);
                    }
                }
            }

            // Exit Monolith
            exitPos.set((s-2)*2, 1.5, (s-2)*2);
            const exitGeo = new THREE.IcosahedronGeometry(1, 0);
            const exitMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
            const exitMesh = new THREE.Mesh(exitGeo, exitMat);
            exitMesh.position.copy(exitPos);
            scene.add(exitMesh);
            
            // Add a light at exit
            const exitLight = new THREE.PointLight(0x00ff00, 2, 10);
            exitLight.position.copy(exitPos);
            scene.add(exitLight);
            
            walls.push(exitMesh); // Collision with exit
        }

        function spawnAnomaly(x, z) {
            // Avant-Garde "NPCs" are floating photo-frames looking at you
            const tex = textureCache.npc[Math.floor(Math.random()*textureCache.npc.length)];
            const geo = new THREE.PlaneGeometry(1, 1.5);
            const mat = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide, transparent: true, opacity: 0.8 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, 2, z);
            scene.add(mesh);
            npcMeshes.push({ mesh: mesh, type: 'observer' });
            
            // Text log logic can go here
        }

        // --- ENTITY LOGIC (The Curator) ---
        let entity;
        function spawnEntity() {
            const mat = new THREE.SpriteMaterial({ map: textureCache.entity });
            entity = new THREE.Sprite(mat);
            entity.scale.set(1.5, 3, 1);
            entity.position.set(2, 2, 2); // Temp
            scene.add(entity);
        }

        // --- GAMEPLAY LOOP ---
        const clock = new THREE.Clock();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        
        let moveFwd = false, moveBwd = false, moveL = false, moveR = false;

        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'KeyW': moveFwd = true; break;
                case 'KeyS': moveBwd = true; break;
                case 'KeyA': moveL = true; break;
                case 'KeyD': moveR = true; break;
                case 'Space': 
                    if(state.flashOn) { flashLight.intensity = 0; state.flashOn = false; }
                    else { flashLight.intensity = 2; state.flashOn = true; }
                    break;
            }
        });
        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': moveFwd = false; break;
                case 'KeyS': moveBwd = false; break;
                case 'KeyA': moveL = false; break;
                case 'KeyD': moveR = false; break;
            }
        });

        // Initialize Game
        document.getElementById('btn-start').addEventListener('click', () => {
            document.getElementById('start-screen').style.display = 'none';
            state.isPlaying = true;
            camera.position.set(2, 1.7, 2); // Start
            generateLevel();
            spawnEntity();
            startAudio();
            controls.lock();
        });

        function animate() {
            requestAnimationFrame(animate);

            if(!state.isPlaying) return;

            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // 1. Post Processing update
            vhsPass.uniforms.time.value = time;
            // Distortion increases as sanity drops
            const insanity = (100 - state.sanity) / 100;
            vhsPass.uniforms.distortion.value = 1.0 + (insanity * 10.0);

            // 2. Movement Physics
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            direction.z = Number(moveFwd) - Number(moveBwd);
            direction.x = Number(moveR) - Number(moveL);
            direction.normalize();

            if (moveFwd || moveBwd) velocity.z -= direction.z * 40.0 * delta;
            if (moveL || moveR) velocity.x -= direction.x * 40.0 * delta;

            const speed = config.moveSpeed;
            controls.moveRight(-velocity.x * delta * speed);
            controls.moveForward(-velocity.z * delta * speed);

            // Footsteps sound
            if((moveFwd || moveBwd || moveL || moveR) && Math.sin(time * 15) > 0.9) {
                // playSound('step'); // Too repetitive? Just rely on ambient.
            }

            // 3. Collision (Simple Box)
            const pPos = camera.position;
            // Bound to map
            if(pPos.x < 0 || pPos.z < 0 || pPos.x > config.mazeSize*2 || pPos.z > config.mazeSize*2) {
                 // Push back
                 controls.moveForward(1);
            }
            
            // Wall Collision
            const cx = Math.floor(pPos.x/2 + 0.5);
            const cy = Math.floor(pPos.z/2 + 0.5);
            // Simple grid check
            try {
                if(floorPlan[cy][cx] === 1) {
                    // Just push back opposite of view
                    controls.moveForward(0.2); 
                }
            } catch(e) {}

            // 4. Entity AI
            if(entity) {
                // Spawn entity far away initially or teleport it
                if(time < 2) entity.position.set((config.mazeSize-2)*2, 2, (config.mazeSize-2)*2);

                const dist = pPos.distanceTo(entity.position);
                
                // If far, move fast. If close, slow down (suspense).
                const eSpeed = dist > 10 ? config.entitySpeed * 1.5 : config.entitySpeed;
                
                // Move towards player
                const dir = new THREE.Vector3().subVectors(pPos, entity.position).normalize();
                entity.position.add(dir.multiplyScalar(eSpeed * delta));
                
                // Bobbing effect
                entity.position.y = 2 + Math.sin(time * 5) * 0.2;

                // Sanity Drain
                if(dist < 8) {
                    state.sanity -= delta * 5;
                    document.getElementById('log').innerText = "WARNING: EXTERNAL PRESENCE DETECTED";
                    // Glitch audio
                    if(lfo) lfo.frequency.value = 10; 
                } else {
                    state.sanity = Math.min(100, state.sanity + delta);
                    if(lfo) lfo.frequency.value = 0.2;
                }

                // Update UI
                document.getElementById('integrity').innerText = `INTEGRITY: ${Math.floor(state.sanity)}%`;

                // Death
                if(dist < 1.0 || state.sanity <= 0) {
                    state.isPlaying = false;
                    document.getElementById('death-screen').style.display = 'flex';
                    controls.unlock();
                    playSound('scream');
                }
            }

            // 5. Avant-Garde Decor Logic
            npcMeshes.forEach(obj => {
                obj.mesh.lookAt(pPos); // They always watch you
                // If you look at them too long, they shake
                const viewDir = new THREE.Vector3();
                camera.getWorldDirection(viewDir);
                const objDir = new THREE.Vector3().subVectors(obj.mesh.position, pPos).normalize();
                if(viewDir.dot(objDir) > 0.9) {
                    obj.mesh.position.x += (Math.random()-0.5)*0.1;
                }
            });

            // 6. Win
            if(pPos.distanceTo(exitPos) < 2.0) {
                document.querySelector('h1').innerText = "UPLOAD COMPLETE";
                document.querySelector('p').innerText = "YOU HAVE ESCAPED THE RECYCLE BIN.";
                document.getElementById('start-screen').style.display = 'flex';
                document.getElementById('btn-start').innerText = "NEW ITERATION";
                state.isPlaying = false;
                controls.unlock();
            }

            composer.render();
        }

        animate();

        // Window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
